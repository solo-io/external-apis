// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	apps_v1 "k8s.io/api/apps/v1"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the Deployment Resource across clusters.
// implemented by the user
type MulticlusterDeploymentReconciler interface {
	ReconcileDeployment(clusterName string, obj *apps_v1.Deployment) (reconcile.Result, error)
}

// Reconcile deletion events for the Deployment Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterDeploymentDeletionReconciler interface {
	ReconcileDeploymentDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterDeploymentReconcilerFuncs struct {
	OnReconcileDeployment         func(clusterName string, obj *apps_v1.Deployment) (reconcile.Result, error)
	OnReconcileDeploymentDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterDeploymentReconcilerFuncs) ReconcileDeployment(clusterName string, obj *apps_v1.Deployment) (reconcile.Result, error) {
	if f.OnReconcileDeployment == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileDeployment(clusterName, obj)
}

func (f *MulticlusterDeploymentReconcilerFuncs) ReconcileDeploymentDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileDeploymentDeletion == nil {
		return nil
	}
	return f.OnReconcileDeploymentDeletion(clusterName, req)
}

type MulticlusterDeploymentReconcileLoop interface {
	// AddMulticlusterDeploymentReconciler adds a MulticlusterDeploymentReconciler to the MulticlusterDeploymentReconcileLoop.
	AddMulticlusterDeploymentReconciler(ctx context.Context, rec MulticlusterDeploymentReconciler, predicates ...predicate.Predicate)
}

type multiclusterDeploymentReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterDeploymentReconcileLoop) AddMulticlusterDeploymentReconciler(ctx context.Context, rec MulticlusterDeploymentReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericDeploymentMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterDeploymentReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterDeploymentReconcileLoop {
	return &multiclusterDeploymentReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &apps_v1.Deployment{}, options)}
}

type genericDeploymentMulticlusterReconciler struct {
	reconciler MulticlusterDeploymentReconciler
}

func (g genericDeploymentMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterDeploymentDeletionReconciler); ok {
		return deletionReconciler.ReconcileDeploymentDeletion(cluster, req)
	}
	return nil
}

func (g genericDeploymentMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apps_v1.Deployment)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Deployment handler received event for %T", object)
	}
	return g.reconciler.ReconcileDeployment(cluster, obj)
}

// Reconcile Upsert events for the ReplicaSet Resource across clusters.
// implemented by the user
type MulticlusterReplicaSetReconciler interface {
	ReconcileReplicaSet(clusterName string, obj *apps_v1.ReplicaSet) (reconcile.Result, error)
}

// Reconcile deletion events for the ReplicaSet Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterReplicaSetDeletionReconciler interface {
	ReconcileReplicaSetDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterReplicaSetReconcilerFuncs struct {
	OnReconcileReplicaSet         func(clusterName string, obj *apps_v1.ReplicaSet) (reconcile.Result, error)
	OnReconcileReplicaSetDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterReplicaSetReconcilerFuncs) ReconcileReplicaSet(clusterName string, obj *apps_v1.ReplicaSet) (reconcile.Result, error) {
	if f.OnReconcileReplicaSet == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileReplicaSet(clusterName, obj)
}

func (f *MulticlusterReplicaSetReconcilerFuncs) ReconcileReplicaSetDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileReplicaSetDeletion == nil {
		return nil
	}
	return f.OnReconcileReplicaSetDeletion(clusterName, req)
}

type MulticlusterReplicaSetReconcileLoop interface {
	// AddMulticlusterReplicaSetReconciler adds a MulticlusterReplicaSetReconciler to the MulticlusterReplicaSetReconcileLoop.
	AddMulticlusterReplicaSetReconciler(ctx context.Context, rec MulticlusterReplicaSetReconciler, predicates ...predicate.Predicate)
}

type multiclusterReplicaSetReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterReplicaSetReconcileLoop) AddMulticlusterReplicaSetReconciler(ctx context.Context, rec MulticlusterReplicaSetReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericReplicaSetMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterReplicaSetReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterReplicaSetReconcileLoop {
	return &multiclusterReplicaSetReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &apps_v1.ReplicaSet{}, options)}
}

type genericReplicaSetMulticlusterReconciler struct {
	reconciler MulticlusterReplicaSetReconciler
}

func (g genericReplicaSetMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterReplicaSetDeletionReconciler); ok {
		return deletionReconciler.ReconcileReplicaSetDeletion(cluster, req)
	}
	return nil
}

func (g genericReplicaSetMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apps_v1.ReplicaSet)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: ReplicaSet handler received event for %T", object)
	}
	return g.reconciler.ReconcileReplicaSet(cluster, obj)
}

// Reconcile Upsert events for the DaemonSet Resource across clusters.
// implemented by the user
type MulticlusterDaemonSetReconciler interface {
	ReconcileDaemonSet(clusterName string, obj *apps_v1.DaemonSet) (reconcile.Result, error)
}

// Reconcile deletion events for the DaemonSet Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterDaemonSetDeletionReconciler interface {
	ReconcileDaemonSetDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterDaemonSetReconcilerFuncs struct {
	OnReconcileDaemonSet         func(clusterName string, obj *apps_v1.DaemonSet) (reconcile.Result, error)
	OnReconcileDaemonSetDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterDaemonSetReconcilerFuncs) ReconcileDaemonSet(clusterName string, obj *apps_v1.DaemonSet) (reconcile.Result, error) {
	if f.OnReconcileDaemonSet == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileDaemonSet(clusterName, obj)
}

func (f *MulticlusterDaemonSetReconcilerFuncs) ReconcileDaemonSetDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileDaemonSetDeletion == nil {
		return nil
	}
	return f.OnReconcileDaemonSetDeletion(clusterName, req)
}

type MulticlusterDaemonSetReconcileLoop interface {
	// AddMulticlusterDaemonSetReconciler adds a MulticlusterDaemonSetReconciler to the MulticlusterDaemonSetReconcileLoop.
	AddMulticlusterDaemonSetReconciler(ctx context.Context, rec MulticlusterDaemonSetReconciler, predicates ...predicate.Predicate)
}

type multiclusterDaemonSetReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterDaemonSetReconcileLoop) AddMulticlusterDaemonSetReconciler(ctx context.Context, rec MulticlusterDaemonSetReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericDaemonSetMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterDaemonSetReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterDaemonSetReconcileLoop {
	return &multiclusterDaemonSetReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &apps_v1.DaemonSet{}, options)}
}

type genericDaemonSetMulticlusterReconciler struct {
	reconciler MulticlusterDaemonSetReconciler
}

func (g genericDaemonSetMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterDaemonSetDeletionReconciler); ok {
		return deletionReconciler.ReconcileDaemonSetDeletion(cluster, req)
	}
	return nil
}

func (g genericDaemonSetMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apps_v1.DaemonSet)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: DaemonSet handler received event for %T", object)
	}
	return g.reconciler.ReconcileDaemonSet(cluster, obj)
}

// Reconcile Upsert events for the StatefulSet Resource across clusters.
// implemented by the user
type MulticlusterStatefulSetReconciler interface {
	ReconcileStatefulSet(clusterName string, obj *apps_v1.StatefulSet) (reconcile.Result, error)
}

// Reconcile deletion events for the StatefulSet Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterStatefulSetDeletionReconciler interface {
	ReconcileStatefulSetDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterStatefulSetReconcilerFuncs struct {
	OnReconcileStatefulSet         func(clusterName string, obj *apps_v1.StatefulSet) (reconcile.Result, error)
	OnReconcileStatefulSetDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterStatefulSetReconcilerFuncs) ReconcileStatefulSet(clusterName string, obj *apps_v1.StatefulSet) (reconcile.Result, error) {
	if f.OnReconcileStatefulSet == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileStatefulSet(clusterName, obj)
}

func (f *MulticlusterStatefulSetReconcilerFuncs) ReconcileStatefulSetDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileStatefulSetDeletion == nil {
		return nil
	}
	return f.OnReconcileStatefulSetDeletion(clusterName, req)
}

type MulticlusterStatefulSetReconcileLoop interface {
	// AddMulticlusterStatefulSetReconciler adds a MulticlusterStatefulSetReconciler to the MulticlusterStatefulSetReconcileLoop.
	AddMulticlusterStatefulSetReconciler(ctx context.Context, rec MulticlusterStatefulSetReconciler, predicates ...predicate.Predicate)
}

type multiclusterStatefulSetReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterStatefulSetReconcileLoop) AddMulticlusterStatefulSetReconciler(ctx context.Context, rec MulticlusterStatefulSetReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericStatefulSetMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterStatefulSetReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterStatefulSetReconcileLoop {
	return &multiclusterStatefulSetReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &apps_v1.StatefulSet{}, options)}
}

type genericStatefulSetMulticlusterReconciler struct {
	reconciler MulticlusterStatefulSetReconciler
}

func (g genericStatefulSetMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterStatefulSetDeletionReconciler); ok {
		return deletionReconciler.ReconcileStatefulSetDeletion(cluster, req)
	}
	return nil
}

func (g genericStatefulSetMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*apps_v1.StatefulSet)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: StatefulSet handler received event for %T", object)
	}
	return g.reconciler.ReconcileStatefulSet(cluster, obj)
}
