// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	apps_v1 "k8s.io/api/apps/v1"

	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type DeploymentSet interface {
	Keys() sets.String
	List() []*apps_v1.Deployment
	Map() map[string]*apps_v1.Deployment
	Insert(deployment ...*apps_v1.Deployment)
	Equal(deploymentSet DeploymentSet) bool
	Has(deployment *apps_v1.Deployment) bool
	Delete(deployment *apps_v1.Deployment)
	Union(set DeploymentSet) DeploymentSet
	Difference(set DeploymentSet) DeploymentSet
	Intersection(set DeploymentSet) DeploymentSet
	Find(id ezkube.ResourceId) (*apps_v1.Deployment, error)
}

func makeGenericDeploymentSet(deploymentList []*apps_v1.Deployment) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range deploymentList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type deploymentSet struct {
	set sksets.ResourceSet
}

func NewDeploymentSet(deploymentList ...*apps_v1.Deployment) DeploymentSet {
	return &deploymentSet{set: makeGenericDeploymentSet(deploymentList)}
}

func (s deploymentSet) Keys() sets.String {
	return s.set.Keys()
}

func (s deploymentSet) List() []*apps_v1.Deployment {
	var deploymentList []*apps_v1.Deployment
	for _, obj := range s.set.List() {
		deploymentList = append(deploymentList, obj.(*apps_v1.Deployment))
	}
	return deploymentList
}

func (s deploymentSet) Map() map[string]*apps_v1.Deployment {
	newMap := map[string]*apps_v1.Deployment{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.Deployment)
	}
	return newMap
}

func (s deploymentSet) Insert(
	deploymentList ...*apps_v1.Deployment,
) {
	for _, obj := range deploymentList {
		s.set.Insert(obj)
	}
}

func (s deploymentSet) Has(deployment *apps_v1.Deployment) bool {
	return s.set.Has(deployment)
}

func (s deploymentSet) Equal(
	deploymentSet DeploymentSet,
) bool {
	return s.set.Equal(makeGenericDeploymentSet(deploymentSet.List()))
}

func (s deploymentSet) Delete(Deployment *apps_v1.Deployment) {
	s.set.Delete(Deployment)
}

func (s deploymentSet) Union(set DeploymentSet) DeploymentSet {
	return NewDeploymentSet(append(s.List(), set.List()...)...)
}

func (s deploymentSet) Difference(set DeploymentSet) DeploymentSet {
	newSet := s.set.Difference(makeGenericDeploymentSet(set.List()))
	return deploymentSet{set: newSet}
}

func (s deploymentSet) Intersection(set DeploymentSet) DeploymentSet {
	newSet := s.set.Intersection(makeGenericDeploymentSet(set.List()))
	var deploymentList []*apps_v1.Deployment
	for _, obj := range newSet.List() {
		deploymentList = append(deploymentList, obj.(*apps_v1.Deployment))
	}
	return NewDeploymentSet(deploymentList...)
}

func (s deploymentSet) Find(id ezkube.ResourceId) (*apps_v1.Deployment, error) {
	obj, err := s.set.Find(&apps_v1.Deployment{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.Deployment), nil
}

type ReplicaSetSet interface {
	Keys() sets.String
	List() []*apps_v1.ReplicaSet
	Map() map[string]*apps_v1.ReplicaSet
	Insert(replicaSet ...*apps_v1.ReplicaSet)
	Equal(replicaSetSet ReplicaSetSet) bool
	Has(replicaSet *apps_v1.ReplicaSet) bool
	Delete(replicaSet *apps_v1.ReplicaSet)
	Union(set ReplicaSetSet) ReplicaSetSet
	Difference(set ReplicaSetSet) ReplicaSetSet
	Intersection(set ReplicaSetSet) ReplicaSetSet
	Find(id ezkube.ResourceId) (*apps_v1.ReplicaSet, error)
}

func makeGenericReplicaSetSet(replicaSetList []*apps_v1.ReplicaSet) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range replicaSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type replicaSetSet struct {
	set sksets.ResourceSet
}

func NewReplicaSetSet(replicaSetList ...*apps_v1.ReplicaSet) ReplicaSetSet {
	return &replicaSetSet{set: makeGenericReplicaSetSet(replicaSetList)}
}

func (s replicaSetSet) Keys() sets.String {
	return s.set.Keys()
}

func (s replicaSetSet) List() []*apps_v1.ReplicaSet {
	var replicaSetList []*apps_v1.ReplicaSet
	for _, obj := range s.set.List() {
		replicaSetList = append(replicaSetList, obj.(*apps_v1.ReplicaSet))
	}
	return replicaSetList
}

func (s replicaSetSet) Map() map[string]*apps_v1.ReplicaSet {
	newMap := map[string]*apps_v1.ReplicaSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.ReplicaSet)
	}
	return newMap
}

func (s replicaSetSet) Insert(
	replicaSetList ...*apps_v1.ReplicaSet,
) {
	for _, obj := range replicaSetList {
		s.set.Insert(obj)
	}
}

func (s replicaSetSet) Has(replicaSet *apps_v1.ReplicaSet) bool {
	return s.set.Has(replicaSet)
}

func (s replicaSetSet) Equal(
	replicaSetSet ReplicaSetSet,
) bool {
	return s.set.Equal(makeGenericReplicaSetSet(replicaSetSet.List()))
}

func (s replicaSetSet) Delete(ReplicaSet *apps_v1.ReplicaSet) {
	s.set.Delete(ReplicaSet)
}

func (s replicaSetSet) Union(set ReplicaSetSet) ReplicaSetSet {
	return NewReplicaSetSet(append(s.List(), set.List()...)...)
}

func (s replicaSetSet) Difference(set ReplicaSetSet) ReplicaSetSet {
	newSet := s.set.Difference(makeGenericReplicaSetSet(set.List()))
	return replicaSetSet{set: newSet}
}

func (s replicaSetSet) Intersection(set ReplicaSetSet) ReplicaSetSet {
	newSet := s.set.Intersection(makeGenericReplicaSetSet(set.List()))
	var replicaSetList []*apps_v1.ReplicaSet
	for _, obj := range newSet.List() {
		replicaSetList = append(replicaSetList, obj.(*apps_v1.ReplicaSet))
	}
	return NewReplicaSetSet(replicaSetList...)
}

func (s replicaSetSet) Find(id ezkube.ResourceId) (*apps_v1.ReplicaSet, error) {
	obj, err := s.set.Find(&apps_v1.ReplicaSet{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.ReplicaSet), nil
}

type DaemonSetSet interface {
	Keys() sets.String
	List() []*apps_v1.DaemonSet
	Map() map[string]*apps_v1.DaemonSet
	Insert(daemonSet ...*apps_v1.DaemonSet)
	Equal(daemonSetSet DaemonSetSet) bool
	Has(daemonSet *apps_v1.DaemonSet) bool
	Delete(daemonSet *apps_v1.DaemonSet)
	Union(set DaemonSetSet) DaemonSetSet
	Difference(set DaemonSetSet) DaemonSetSet
	Intersection(set DaemonSetSet) DaemonSetSet
	Find(id ezkube.ResourceId) (*apps_v1.DaemonSet, error)
}

func makeGenericDaemonSetSet(daemonSetList []*apps_v1.DaemonSet) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range daemonSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type daemonSetSet struct {
	set sksets.ResourceSet
}

func NewDaemonSetSet(daemonSetList ...*apps_v1.DaemonSet) DaemonSetSet {
	return &daemonSetSet{set: makeGenericDaemonSetSet(daemonSetList)}
}

func (s daemonSetSet) Keys() sets.String {
	return s.set.Keys()
}

func (s daemonSetSet) List() []*apps_v1.DaemonSet {
	var daemonSetList []*apps_v1.DaemonSet
	for _, obj := range s.set.List() {
		daemonSetList = append(daemonSetList, obj.(*apps_v1.DaemonSet))
	}
	return daemonSetList
}

func (s daemonSetSet) Map() map[string]*apps_v1.DaemonSet {
	newMap := map[string]*apps_v1.DaemonSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.DaemonSet)
	}
	return newMap
}

func (s daemonSetSet) Insert(
	daemonSetList ...*apps_v1.DaemonSet,
) {
	for _, obj := range daemonSetList {
		s.set.Insert(obj)
	}
}

func (s daemonSetSet) Has(daemonSet *apps_v1.DaemonSet) bool {
	return s.set.Has(daemonSet)
}

func (s daemonSetSet) Equal(
	daemonSetSet DaemonSetSet,
) bool {
	return s.set.Equal(makeGenericDaemonSetSet(daemonSetSet.List()))
}

func (s daemonSetSet) Delete(DaemonSet *apps_v1.DaemonSet) {
	s.set.Delete(DaemonSet)
}

func (s daemonSetSet) Union(set DaemonSetSet) DaemonSetSet {
	return NewDaemonSetSet(append(s.List(), set.List()...)...)
}

func (s daemonSetSet) Difference(set DaemonSetSet) DaemonSetSet {
	newSet := s.set.Difference(makeGenericDaemonSetSet(set.List()))
	return daemonSetSet{set: newSet}
}

func (s daemonSetSet) Intersection(set DaemonSetSet) DaemonSetSet {
	newSet := s.set.Intersection(makeGenericDaemonSetSet(set.List()))
	var daemonSetList []*apps_v1.DaemonSet
	for _, obj := range newSet.List() {
		daemonSetList = append(daemonSetList, obj.(*apps_v1.DaemonSet))
	}
	return NewDaemonSetSet(daemonSetList...)
}

func (s daemonSetSet) Find(id ezkube.ResourceId) (*apps_v1.DaemonSet, error) {
	obj, err := s.set.Find(&apps_v1.DaemonSet{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.DaemonSet), nil
}

type StatefulSetSet interface {
	Keys() sets.String
	List() []*apps_v1.StatefulSet
	Map() map[string]*apps_v1.StatefulSet
	Insert(statefulSet ...*apps_v1.StatefulSet)
	Equal(statefulSetSet StatefulSetSet) bool
	Has(statefulSet *apps_v1.StatefulSet) bool
	Delete(statefulSet *apps_v1.StatefulSet)
	Union(set StatefulSetSet) StatefulSetSet
	Difference(set StatefulSetSet) StatefulSetSet
	Intersection(set StatefulSetSet) StatefulSetSet
	Find(id ezkube.ResourceId) (*apps_v1.StatefulSet, error)
}

func makeGenericStatefulSetSet(statefulSetList []*apps_v1.StatefulSet) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range statefulSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type statefulSetSet struct {
	set sksets.ResourceSet
}

func NewStatefulSetSet(statefulSetList ...*apps_v1.StatefulSet) StatefulSetSet {
	return &statefulSetSet{set: makeGenericStatefulSetSet(statefulSetList)}
}

func (s statefulSetSet) Keys() sets.String {
	return s.set.Keys()
}

func (s statefulSetSet) List() []*apps_v1.StatefulSet {
	var statefulSetList []*apps_v1.StatefulSet
	for _, obj := range s.set.List() {
		statefulSetList = append(statefulSetList, obj.(*apps_v1.StatefulSet))
	}
	return statefulSetList
}

func (s statefulSetSet) Map() map[string]*apps_v1.StatefulSet {
	newMap := map[string]*apps_v1.StatefulSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.StatefulSet)
	}
	return newMap
}

func (s statefulSetSet) Insert(
	statefulSetList ...*apps_v1.StatefulSet,
) {
	for _, obj := range statefulSetList {
		s.set.Insert(obj)
	}
}

func (s statefulSetSet) Has(statefulSet *apps_v1.StatefulSet) bool {
	return s.set.Has(statefulSet)
}

func (s statefulSetSet) Equal(
	statefulSetSet StatefulSetSet,
) bool {
	return s.set.Equal(makeGenericStatefulSetSet(statefulSetSet.List()))
}

func (s statefulSetSet) Delete(StatefulSet *apps_v1.StatefulSet) {
	s.set.Delete(StatefulSet)
}

func (s statefulSetSet) Union(set StatefulSetSet) StatefulSetSet {
	return NewStatefulSetSet(append(s.List(), set.List()...)...)
}

func (s statefulSetSet) Difference(set StatefulSetSet) StatefulSetSet {
	newSet := s.set.Difference(makeGenericStatefulSetSet(set.List()))
	return statefulSetSet{set: newSet}
}

func (s statefulSetSet) Intersection(set StatefulSetSet) StatefulSetSet {
	newSet := s.set.Intersection(makeGenericStatefulSetSet(set.List()))
	var statefulSetList []*apps_v1.StatefulSet
	for _, obj := range newSet.List() {
		statefulSetList = append(statefulSetList, obj.(*apps_v1.StatefulSet))
	}
	return NewStatefulSetSet(statefulSetList...)
}

func (s statefulSetSet) Find(id ezkube.ResourceId) (*apps_v1.StatefulSet, error) {
	obj, err := s.set.Find(&apps_v1.StatefulSet{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.StatefulSet), nil
}
