// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	apps_v1 "k8s.io/api/apps/v1"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type DeploymentSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*apps_v1.Deployment) bool) []*apps_v1.Deployment
	// Return the Set as a map of key to resource.
	Map() map[string]*apps_v1.Deployment
	// Insert a resource into the set.
	Insert(deployment ...*apps_v1.Deployment)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(deploymentSet DeploymentSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(deployment ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(deployment ezkube.ResourceId)
	// Return the union with the provided set
	Union(set DeploymentSet) DeploymentSet
	// Return the difference with the provided set
	Difference(set DeploymentSet) DeploymentSet
	// Return the intersection with the provided set
	Intersection(set DeploymentSet) DeploymentSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*apps_v1.Deployment, error)
	// Get the length of the set
	Length() int
}

func makeGenericDeploymentSet(deploymentList []*apps_v1.Deployment) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range deploymentList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type deploymentSet struct {
	set sksets.ResourceSet
}

func NewDeploymentSet(deploymentList ...*apps_v1.Deployment) DeploymentSet {
	return &deploymentSet{set: makeGenericDeploymentSet(deploymentList)}
}

func NewDeploymentSetFromList(deploymentList *apps_v1.DeploymentList) DeploymentSet {
	list := make([]*apps_v1.Deployment, 0, len(deploymentList.Items))
	for idx := range deploymentList.Items {
		list = append(list, &deploymentList.Items[idx])
	}
	return &deploymentSet{set: makeGenericDeploymentSet(list)}
}

func (s *deploymentSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *deploymentSet) List(filterResource ...func(*apps_v1.Deployment) bool) []*apps_v1.Deployment {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*apps_v1.Deployment))
		})
	}

	var deploymentList []*apps_v1.Deployment
	for _, obj := range s.set.List(genericFilters...) {
		deploymentList = append(deploymentList, obj.(*apps_v1.Deployment))
	}
	return deploymentList
}

func (s *deploymentSet) Map() map[string]*apps_v1.Deployment {
	if s == nil {
		return nil
	}

	newMap := map[string]*apps_v1.Deployment{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.Deployment)
	}
	return newMap
}

func (s *deploymentSet) Insert(
	deploymentList ...*apps_v1.Deployment,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range deploymentList {
		s.set.Insert(obj)
	}
}

func (s *deploymentSet) Has(deployment ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(deployment)
}

func (s *deploymentSet) Equal(
	deploymentSet DeploymentSet,
) bool {
	if s == nil {
		return deploymentSet == nil
	}
	return s.set.Equal(makeGenericDeploymentSet(deploymentSet.List()))
}

func (s *deploymentSet) Delete(Deployment ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(Deployment)
}

func (s *deploymentSet) Union(set DeploymentSet) DeploymentSet {
	if s == nil {
		return set
	}
	return NewDeploymentSet(append(s.List(), set.List()...)...)
}

func (s *deploymentSet) Difference(set DeploymentSet) DeploymentSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericDeploymentSet(set.List()))
	return &deploymentSet{set: newSet}
}

func (s *deploymentSet) Intersection(set DeploymentSet) DeploymentSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericDeploymentSet(set.List()))
	var deploymentList []*apps_v1.Deployment
	for _, obj := range newSet.List() {
		deploymentList = append(deploymentList, obj.(*apps_v1.Deployment))
	}
	return NewDeploymentSet(deploymentList...)
}

func (s *deploymentSet) Find(id ezkube.ResourceId) (*apps_v1.Deployment, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Deployment %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&apps_v1.Deployment{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.Deployment), nil
}

func (s *deploymentSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type ReplicaSetSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*apps_v1.ReplicaSet) bool) []*apps_v1.ReplicaSet
	// Return the Set as a map of key to resource.
	Map() map[string]*apps_v1.ReplicaSet
	// Insert a resource into the set.
	Insert(replicaSet ...*apps_v1.ReplicaSet)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(replicaSetSet ReplicaSetSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(replicaSet ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(replicaSet ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ReplicaSetSet) ReplicaSetSet
	// Return the difference with the provided set
	Difference(set ReplicaSetSet) ReplicaSetSet
	// Return the intersection with the provided set
	Intersection(set ReplicaSetSet) ReplicaSetSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*apps_v1.ReplicaSet, error)
	// Get the length of the set
	Length() int
}

func makeGenericReplicaSetSet(replicaSetList []*apps_v1.ReplicaSet) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range replicaSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type replicaSetSet struct {
	set sksets.ResourceSet
}

func NewReplicaSetSet(replicaSetList ...*apps_v1.ReplicaSet) ReplicaSetSet {
	return &replicaSetSet{set: makeGenericReplicaSetSet(replicaSetList)}
}

func NewReplicaSetSetFromList(replicaSetList *apps_v1.ReplicaSetList) ReplicaSetSet {
	list := make([]*apps_v1.ReplicaSet, 0, len(replicaSetList.Items))
	for idx := range replicaSetList.Items {
		list = append(list, &replicaSetList.Items[idx])
	}
	return &replicaSetSet{set: makeGenericReplicaSetSet(list)}
}

func (s *replicaSetSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *replicaSetSet) List(filterResource ...func(*apps_v1.ReplicaSet) bool) []*apps_v1.ReplicaSet {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*apps_v1.ReplicaSet))
		})
	}

	var replicaSetList []*apps_v1.ReplicaSet
	for _, obj := range s.set.List(genericFilters...) {
		replicaSetList = append(replicaSetList, obj.(*apps_v1.ReplicaSet))
	}
	return replicaSetList
}

func (s *replicaSetSet) Map() map[string]*apps_v1.ReplicaSet {
	if s == nil {
		return nil
	}

	newMap := map[string]*apps_v1.ReplicaSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.ReplicaSet)
	}
	return newMap
}

func (s *replicaSetSet) Insert(
	replicaSetList ...*apps_v1.ReplicaSet,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range replicaSetList {
		s.set.Insert(obj)
	}
}

func (s *replicaSetSet) Has(replicaSet ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(replicaSet)
}

func (s *replicaSetSet) Equal(
	replicaSetSet ReplicaSetSet,
) bool {
	if s == nil {
		return replicaSetSet == nil
	}
	return s.set.Equal(makeGenericReplicaSetSet(replicaSetSet.List()))
}

func (s *replicaSetSet) Delete(ReplicaSet ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(ReplicaSet)
}

func (s *replicaSetSet) Union(set ReplicaSetSet) ReplicaSetSet {
	if s == nil {
		return set
	}
	return NewReplicaSetSet(append(s.List(), set.List()...)...)
}

func (s *replicaSetSet) Difference(set ReplicaSetSet) ReplicaSetSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericReplicaSetSet(set.List()))
	return &replicaSetSet{set: newSet}
}

func (s *replicaSetSet) Intersection(set ReplicaSetSet) ReplicaSetSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericReplicaSetSet(set.List()))
	var replicaSetList []*apps_v1.ReplicaSet
	for _, obj := range newSet.List() {
		replicaSetList = append(replicaSetList, obj.(*apps_v1.ReplicaSet))
	}
	return NewReplicaSetSet(replicaSetList...)
}

func (s *replicaSetSet) Find(id ezkube.ResourceId) (*apps_v1.ReplicaSet, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ReplicaSet %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&apps_v1.ReplicaSet{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.ReplicaSet), nil
}

func (s *replicaSetSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type DaemonSetSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*apps_v1.DaemonSet) bool) []*apps_v1.DaemonSet
	// Return the Set as a map of key to resource.
	Map() map[string]*apps_v1.DaemonSet
	// Insert a resource into the set.
	Insert(daemonSet ...*apps_v1.DaemonSet)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(daemonSetSet DaemonSetSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(daemonSet ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(daemonSet ezkube.ResourceId)
	// Return the union with the provided set
	Union(set DaemonSetSet) DaemonSetSet
	// Return the difference with the provided set
	Difference(set DaemonSetSet) DaemonSetSet
	// Return the intersection with the provided set
	Intersection(set DaemonSetSet) DaemonSetSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*apps_v1.DaemonSet, error)
	// Get the length of the set
	Length() int
}

func makeGenericDaemonSetSet(daemonSetList []*apps_v1.DaemonSet) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range daemonSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type daemonSetSet struct {
	set sksets.ResourceSet
}

func NewDaemonSetSet(daemonSetList ...*apps_v1.DaemonSet) DaemonSetSet {
	return &daemonSetSet{set: makeGenericDaemonSetSet(daemonSetList)}
}

func NewDaemonSetSetFromList(daemonSetList *apps_v1.DaemonSetList) DaemonSetSet {
	list := make([]*apps_v1.DaemonSet, 0, len(daemonSetList.Items))
	for idx := range daemonSetList.Items {
		list = append(list, &daemonSetList.Items[idx])
	}
	return &daemonSetSet{set: makeGenericDaemonSetSet(list)}
}

func (s *daemonSetSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *daemonSetSet) List(filterResource ...func(*apps_v1.DaemonSet) bool) []*apps_v1.DaemonSet {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*apps_v1.DaemonSet))
		})
	}

	var daemonSetList []*apps_v1.DaemonSet
	for _, obj := range s.set.List(genericFilters...) {
		daemonSetList = append(daemonSetList, obj.(*apps_v1.DaemonSet))
	}
	return daemonSetList
}

func (s *daemonSetSet) Map() map[string]*apps_v1.DaemonSet {
	if s == nil {
		return nil
	}

	newMap := map[string]*apps_v1.DaemonSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.DaemonSet)
	}
	return newMap
}

func (s *daemonSetSet) Insert(
	daemonSetList ...*apps_v1.DaemonSet,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range daemonSetList {
		s.set.Insert(obj)
	}
}

func (s *daemonSetSet) Has(daemonSet ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(daemonSet)
}

func (s *daemonSetSet) Equal(
	daemonSetSet DaemonSetSet,
) bool {
	if s == nil {
		return daemonSetSet == nil
	}
	return s.set.Equal(makeGenericDaemonSetSet(daemonSetSet.List()))
}

func (s *daemonSetSet) Delete(DaemonSet ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(DaemonSet)
}

func (s *daemonSetSet) Union(set DaemonSetSet) DaemonSetSet {
	if s == nil {
		return set
	}
	return NewDaemonSetSet(append(s.List(), set.List()...)...)
}

func (s *daemonSetSet) Difference(set DaemonSetSet) DaemonSetSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericDaemonSetSet(set.List()))
	return &daemonSetSet{set: newSet}
}

func (s *daemonSetSet) Intersection(set DaemonSetSet) DaemonSetSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericDaemonSetSet(set.List()))
	var daemonSetList []*apps_v1.DaemonSet
	for _, obj := range newSet.List() {
		daemonSetList = append(daemonSetList, obj.(*apps_v1.DaemonSet))
	}
	return NewDaemonSetSet(daemonSetList...)
}

func (s *daemonSetSet) Find(id ezkube.ResourceId) (*apps_v1.DaemonSet, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find DaemonSet %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&apps_v1.DaemonSet{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.DaemonSet), nil
}

func (s *daemonSetSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}

type StatefulSetSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*apps_v1.StatefulSet) bool) []*apps_v1.StatefulSet
	// Return the Set as a map of key to resource.
	Map() map[string]*apps_v1.StatefulSet
	// Insert a resource into the set.
	Insert(statefulSet ...*apps_v1.StatefulSet)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(statefulSetSet StatefulSetSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(statefulSet ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(statefulSet ezkube.ResourceId)
	// Return the union with the provided set
	Union(set StatefulSetSet) StatefulSetSet
	// Return the difference with the provided set
	Difference(set StatefulSetSet) StatefulSetSet
	// Return the intersection with the provided set
	Intersection(set StatefulSetSet) StatefulSetSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*apps_v1.StatefulSet, error)
	// Get the length of the set
	Length() int
}

func makeGenericStatefulSetSet(statefulSetList []*apps_v1.StatefulSet) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range statefulSetList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type statefulSetSet struct {
	set sksets.ResourceSet
}

func NewStatefulSetSet(statefulSetList ...*apps_v1.StatefulSet) StatefulSetSet {
	return &statefulSetSet{set: makeGenericStatefulSetSet(statefulSetList)}
}

func NewStatefulSetSetFromList(statefulSetList *apps_v1.StatefulSetList) StatefulSetSet {
	list := make([]*apps_v1.StatefulSet, 0, len(statefulSetList.Items))
	for idx := range statefulSetList.Items {
		list = append(list, &statefulSetList.Items[idx])
	}
	return &statefulSetSet{set: makeGenericStatefulSetSet(list)}
}

func (s *statefulSetSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.set.Keys()
}

func (s *statefulSetSet) List(filterResource ...func(*apps_v1.StatefulSet) bool) []*apps_v1.StatefulSet {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*apps_v1.StatefulSet))
		})
	}

	var statefulSetList []*apps_v1.StatefulSet
	for _, obj := range s.set.List(genericFilters...) {
		statefulSetList = append(statefulSetList, obj.(*apps_v1.StatefulSet))
	}
	return statefulSetList
}

func (s *statefulSetSet) Map() map[string]*apps_v1.StatefulSet {
	if s == nil {
		return nil
	}

	newMap := map[string]*apps_v1.StatefulSet{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*apps_v1.StatefulSet)
	}
	return newMap
}

func (s *statefulSetSet) Insert(
	statefulSetList ...*apps_v1.StatefulSet,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range statefulSetList {
		s.set.Insert(obj)
	}
}

func (s *statefulSetSet) Has(statefulSet ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.set.Has(statefulSet)
}

func (s *statefulSetSet) Equal(
	statefulSetSet StatefulSetSet,
) bool {
	if s == nil {
		return statefulSetSet == nil
	}
	return s.set.Equal(makeGenericStatefulSetSet(statefulSetSet.List()))
}

func (s *statefulSetSet) Delete(StatefulSet ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.set.Delete(StatefulSet)
}

func (s *statefulSetSet) Union(set StatefulSetSet) StatefulSetSet {
	if s == nil {
		return set
	}
	return NewStatefulSetSet(append(s.List(), set.List()...)...)
}

func (s *statefulSetSet) Difference(set StatefulSetSet) StatefulSetSet {
	if s == nil {
		return set
	}
	newSet := s.set.Difference(makeGenericStatefulSetSet(set.List()))
	return &statefulSetSet{set: newSet}
}

func (s *statefulSetSet) Intersection(set StatefulSetSet) StatefulSetSet {
	if s == nil {
		return nil
	}
	newSet := s.set.Intersection(makeGenericStatefulSetSet(set.List()))
	var statefulSetList []*apps_v1.StatefulSet
	for _, obj := range newSet.List() {
		statefulSetList = append(statefulSetList, obj.(*apps_v1.StatefulSet))
	}
	return NewStatefulSetSet(statefulSetList...)
}

func (s *statefulSetSet) Find(id ezkube.ResourceId) (*apps_v1.StatefulSet, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find StatefulSet %v", sksets.Key(id))
	}
	obj, err := s.set.Find(&apps_v1.StatefulSet{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*apps_v1.StatefulSet), nil
}

func (s *statefulSetSet) Length() int {
	if s == nil {
		return 0
	}
	return s.set.Length()
}
