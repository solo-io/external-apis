// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	v1 "k8s.io/api/core/v1"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type SecretSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.Secret) bool) []*v1.Secret
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.Secret) bool) []*v1.Secret
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.Secret
	// Insert a resource into the set.
	Insert(secret ...*v1.Secret)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(secretSet SecretSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(secret ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(secret ezkube.ResourceId)
	// Return the union with the provided set
	Union(set SecretSet) SecretSet
	// Return the difference with the provided set
	Difference(set SecretSet) SecretSet
	// Return the intersection with the provided set
	Intersection(set SecretSet) SecretSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.Secret, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another SecretSet
	Delta(newSet SecretSet) sksets.ResourceDelta
	// Create a deep copy of the current SecretSet
	Clone() SecretSet
}

func makeGenericSecretSet(secretList []*v1.Secret) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range secretList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type secretSet struct {
	set sksets.ResourceSet
}

func NewSecretSet(secretList ...*v1.Secret) SecretSet {
	return &secretSet{set: makeGenericSecretSet(secretList)}
}

func NewSecretSetFromList(secretList *v1.SecretList) SecretSet {
	list := make([]*v1.Secret, 0, len(secretList.Items))
	for idx := range secretList.Items {
		list = append(list, &secretList.Items[idx])
	}
	return &secretSet{set: makeGenericSecretSet(list)}
}

func (s *secretSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *secretSet) List(filterResource ...func(*v1.Secret) bool) []*v1.Secret {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Secret))
		})
	}

	objs := s.Generic().List(genericFilters...)
	secretList := make([]*v1.Secret, 0, len(objs))
	for _, obj := range objs {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return secretList
}

func (s *secretSet) UnsortedList(filterResource ...func(*v1.Secret) bool) []*v1.Secret {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Secret))
		})
	}

	var secretList []*v1.Secret
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return secretList
}

func (s *secretSet) Map() map[string]*v1.Secret {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Secret{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.Secret)
	}
	return newMap
}

func (s *secretSet) Insert(
	secretList ...*v1.Secret,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range secretList {
		s.Generic().Insert(obj)
	}
}

func (s *secretSet) Has(secret ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(secret)
}

func (s *secretSet) Equal(
	secretSet SecretSet,
) bool {
	if s == nil {
		return secretSet == nil
	}
	return s.Generic().Equal(secretSet.Generic())
}

func (s *secretSet) Delete(Secret ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Secret)
}

func (s *secretSet) Union(set SecretSet) SecretSet {
	if s == nil {
		return set
	}
	return &secretMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *secretSet) Difference(set SecretSet) SecretSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &secretSet{set: newSet}
}

func (s *secretSet) Intersection(set SecretSet) SecretSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var secretList []*v1.Secret
	for _, obj := range newSet.List() {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return NewSecretSet(secretList...)
}

func (s *secretSet) Find(id ezkube.ResourceId) (*v1.Secret, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Secret %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.Secret{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Secret), nil
}

func (s *secretSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *secretSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *secretSet) Delta(newSet SecretSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *secretSet) Clone() SecretSet {
	if s == nil {
		return nil
	}
	return &secretMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type secretMergedSet struct {
	sets []sksets.ResourceSet
}

func NewSecretMergedSet(secretList ...*v1.Secret) SecretSet {
	return &secretMergedSet{sets: []sksets.ResourceSet{makeGenericSecretSet(secretList)}}
}

func NewSecretMergedSetFromList(secretList *v1.SecretList) SecretSet {
	list := make([]*v1.Secret, 0, len(secretList.Items))
	for idx := range secretList.Items {
		list = append(list, &secretList.Items[idx])
	}
	return &secretMergedSet{sets: []sksets.ResourceSet{makeGenericSecretSet(list)}}
}

func (s *secretMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *secretMergedSet) List(filterResource ...func(*v1.Secret) bool) []*v1.Secret {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Secret))
		})
	}
	secretList := []*v1.Secret{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			secretList = append(secretList, obj.(*v1.Secret))
		}
	}
	return secretList
}

func (s *secretMergedSet) UnsortedList(filterResource ...func(*v1.Secret) bool) []*v1.Secret {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Secret))
		})
	}

	secretList := []*v1.Secret{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			secretList = append(secretList, obj.(*v1.Secret))
		}
	}
	return secretList
}

func (s *secretMergedSet) Map() map[string]*v1.Secret {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Secret{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.Secret)
		}
	}
	return newMap
}

func (s *secretMergedSet) Insert(
	secretList ...*v1.Secret,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericSecretSet(secretList))
	}
	for _, obj := range secretList {
		s.sets[0].Insert(obj)
	}
}

func (s *secretMergedSet) Has(secret ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(secret) {
			return true
		}
	}
	return false
}

func (s *secretMergedSet) Equal(
	secretSet SecretSet,
) bool {
	panic("unimplemented")
}

func (s *secretMergedSet) Delete(Secret ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *secretMergedSet) Union(set SecretSet) SecretSet {
	return &secretMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *secretMergedSet) Difference(set SecretSet) SecretSet {
	panic("unimplemented")
}

func (s *secretMergedSet) Intersection(set SecretSet) SecretSet {
	panic("unimplemented")
}

func (s *secretMergedSet) Find(id ezkube.ResourceId) (*v1.Secret, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Secret %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.Secret{}, id)
		if err == nil {
			return obj.(*v1.Secret), nil
		}
	}

	return nil, err
}

func (s *secretMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *secretMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *secretMergedSet) Delta(newSet SecretSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *secretMergedSet) Clone() SecretSet {
	if s == nil {
		return nil
	}
	return &secretMergedSet{sets: s.sets[:]}
}

type ServiceAccountSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.ServiceAccount) bool) []*v1.ServiceAccount
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.ServiceAccount) bool) []*v1.ServiceAccount
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.ServiceAccount
	// Insert a resource into the set.
	Insert(serviceAccount ...*v1.ServiceAccount)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(serviceAccountSet ServiceAccountSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(serviceAccount ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(serviceAccount ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ServiceAccountSet) ServiceAccountSet
	// Return the difference with the provided set
	Difference(set ServiceAccountSet) ServiceAccountSet
	// Return the intersection with the provided set
	Intersection(set ServiceAccountSet) ServiceAccountSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.ServiceAccount, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ServiceAccountSet
	Delta(newSet ServiceAccountSet) sksets.ResourceDelta
	// Create a deep copy of the current ServiceAccountSet
	Clone() ServiceAccountSet
}

func makeGenericServiceAccountSet(serviceAccountList []*v1.ServiceAccount) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range serviceAccountList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceAccountSet struct {
	set sksets.ResourceSet
}

func NewServiceAccountSet(serviceAccountList ...*v1.ServiceAccount) ServiceAccountSet {
	return &serviceAccountSet{set: makeGenericServiceAccountSet(serviceAccountList)}
}

func NewServiceAccountSetFromList(serviceAccountList *v1.ServiceAccountList) ServiceAccountSet {
	list := make([]*v1.ServiceAccount, 0, len(serviceAccountList.Items))
	for idx := range serviceAccountList.Items {
		list = append(list, &serviceAccountList.Items[idx])
	}
	return &serviceAccountSet{set: makeGenericServiceAccountSet(list)}
}

func (s *serviceAccountSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *serviceAccountSet) List(filterResource ...func(*v1.ServiceAccount) bool) []*v1.ServiceAccount {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ServiceAccount))
		})
	}

	objs := s.Generic().List(genericFilters...)
	serviceAccountList := make([]*v1.ServiceAccount, 0, len(objs))
	for _, obj := range objs {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return serviceAccountList
}

func (s *serviceAccountSet) UnsortedList(filterResource ...func(*v1.ServiceAccount) bool) []*v1.ServiceAccount {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ServiceAccount))
		})
	}

	var serviceAccountList []*v1.ServiceAccount
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return serviceAccountList
}

func (s *serviceAccountSet) Map() map[string]*v1.ServiceAccount {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.ServiceAccount{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.ServiceAccount)
	}
	return newMap
}

func (s *serviceAccountSet) Insert(
	serviceAccountList ...*v1.ServiceAccount,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range serviceAccountList {
		s.Generic().Insert(obj)
	}
}

func (s *serviceAccountSet) Has(serviceAccount ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(serviceAccount)
}

func (s *serviceAccountSet) Equal(
	serviceAccountSet ServiceAccountSet,
) bool {
	if s == nil {
		return serviceAccountSet == nil
	}
	return s.Generic().Equal(serviceAccountSet.Generic())
}

func (s *serviceAccountSet) Delete(ServiceAccount ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ServiceAccount)
}

func (s *serviceAccountSet) Union(set ServiceAccountSet) ServiceAccountSet {
	if s == nil {
		return set
	}
	return &serviceAccountMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *serviceAccountSet) Difference(set ServiceAccountSet) ServiceAccountSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &serviceAccountSet{set: newSet}
}

func (s *serviceAccountSet) Intersection(set ServiceAccountSet) ServiceAccountSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var serviceAccountList []*v1.ServiceAccount
	for _, obj := range newSet.List() {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return NewServiceAccountSet(serviceAccountList...)
}

func (s *serviceAccountSet) Find(id ezkube.ResourceId) (*v1.ServiceAccount, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ServiceAccount %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.ServiceAccount{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.ServiceAccount), nil
}

func (s *serviceAccountSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *serviceAccountSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *serviceAccountSet) Delta(newSet ServiceAccountSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *serviceAccountSet) Clone() ServiceAccountSet {
	if s == nil {
		return nil
	}
	return &serviceAccountMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type serviceAccountMergedSet struct {
	sets []sksets.ResourceSet
}

func NewServiceAccountMergedSet(serviceAccountList ...*v1.ServiceAccount) ServiceAccountSet {
	return &serviceAccountMergedSet{sets: []sksets.ResourceSet{makeGenericServiceAccountSet(serviceAccountList)}}
}

func NewServiceAccountMergedSetFromList(serviceAccountList *v1.ServiceAccountList) ServiceAccountSet {
	list := make([]*v1.ServiceAccount, 0, len(serviceAccountList.Items))
	for idx := range serviceAccountList.Items {
		list = append(list, &serviceAccountList.Items[idx])
	}
	return &serviceAccountMergedSet{sets: []sksets.ResourceSet{makeGenericServiceAccountSet(list)}}
}

func (s *serviceAccountMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *serviceAccountMergedSet) List(filterResource ...func(*v1.ServiceAccount) bool) []*v1.ServiceAccount {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ServiceAccount))
		})
	}
	serviceAccountList := []*v1.ServiceAccount{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
		}
	}
	return serviceAccountList
}

func (s *serviceAccountMergedSet) UnsortedList(filterResource ...func(*v1.ServiceAccount) bool) []*v1.ServiceAccount {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ServiceAccount))
		})
	}

	serviceAccountList := []*v1.ServiceAccount{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
		}
	}
	return serviceAccountList
}

func (s *serviceAccountMergedSet) Map() map[string]*v1.ServiceAccount {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.ServiceAccount{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.ServiceAccount)
		}
	}
	return newMap
}

func (s *serviceAccountMergedSet) Insert(
	serviceAccountList ...*v1.ServiceAccount,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericServiceAccountSet(serviceAccountList))
	}
	for _, obj := range serviceAccountList {
		s.sets[0].Insert(obj)
	}
}

func (s *serviceAccountMergedSet) Has(serviceAccount ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(serviceAccount) {
			return true
		}
	}
	return false
}

func (s *serviceAccountMergedSet) Equal(
	serviceAccountSet ServiceAccountSet,
) bool {
	panic("unimplemented")
}

func (s *serviceAccountMergedSet) Delete(ServiceAccount ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *serviceAccountMergedSet) Union(set ServiceAccountSet) ServiceAccountSet {
	return &serviceAccountMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *serviceAccountMergedSet) Difference(set ServiceAccountSet) ServiceAccountSet {
	panic("unimplemented")
}

func (s *serviceAccountMergedSet) Intersection(set ServiceAccountSet) ServiceAccountSet {
	panic("unimplemented")
}

func (s *serviceAccountMergedSet) Find(id ezkube.ResourceId) (*v1.ServiceAccount, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ServiceAccount %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.ServiceAccount{}, id)
		if err == nil {
			return obj.(*v1.ServiceAccount), nil
		}
	}

	return nil, err
}

func (s *serviceAccountMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *serviceAccountMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *serviceAccountMergedSet) Delta(newSet ServiceAccountSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *serviceAccountMergedSet) Clone() ServiceAccountSet {
	if s == nil {
		return nil
	}
	return &serviceAccountMergedSet{sets: s.sets[:]}
}

type ConfigMapSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.ConfigMap) bool) []*v1.ConfigMap
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.ConfigMap) bool) []*v1.ConfigMap
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.ConfigMap
	// Insert a resource into the set.
	Insert(configMap ...*v1.ConfigMap)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(configMapSet ConfigMapSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(configMap ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(configMap ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ConfigMapSet) ConfigMapSet
	// Return the difference with the provided set
	Difference(set ConfigMapSet) ConfigMapSet
	// Return the intersection with the provided set
	Intersection(set ConfigMapSet) ConfigMapSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.ConfigMap, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ConfigMapSet
	Delta(newSet ConfigMapSet) sksets.ResourceDelta
	// Create a deep copy of the current ConfigMapSet
	Clone() ConfigMapSet
}

func makeGenericConfigMapSet(configMapList []*v1.ConfigMap) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range configMapList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type configMapSet struct {
	set sksets.ResourceSet
}

func NewConfigMapSet(configMapList ...*v1.ConfigMap) ConfigMapSet {
	return &configMapSet{set: makeGenericConfigMapSet(configMapList)}
}

func NewConfigMapSetFromList(configMapList *v1.ConfigMapList) ConfigMapSet {
	list := make([]*v1.ConfigMap, 0, len(configMapList.Items))
	for idx := range configMapList.Items {
		list = append(list, &configMapList.Items[idx])
	}
	return &configMapSet{set: makeGenericConfigMapSet(list)}
}

func (s *configMapSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *configMapSet) List(filterResource ...func(*v1.ConfigMap) bool) []*v1.ConfigMap {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ConfigMap))
		})
	}

	objs := s.Generic().List(genericFilters...)
	configMapList := make([]*v1.ConfigMap, 0, len(objs))
	for _, obj := range objs {
		configMapList = append(configMapList, obj.(*v1.ConfigMap))
	}
	return configMapList
}

func (s *configMapSet) UnsortedList(filterResource ...func(*v1.ConfigMap) bool) []*v1.ConfigMap {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ConfigMap))
		})
	}

	var configMapList []*v1.ConfigMap
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		configMapList = append(configMapList, obj.(*v1.ConfigMap))
	}
	return configMapList
}

func (s *configMapSet) Map() map[string]*v1.ConfigMap {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.ConfigMap{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.ConfigMap)
	}
	return newMap
}

func (s *configMapSet) Insert(
	configMapList ...*v1.ConfigMap,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range configMapList {
		s.Generic().Insert(obj)
	}
}

func (s *configMapSet) Has(configMap ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(configMap)
}

func (s *configMapSet) Equal(
	configMapSet ConfigMapSet,
) bool {
	if s == nil {
		return configMapSet == nil
	}
	return s.Generic().Equal(configMapSet.Generic())
}

func (s *configMapSet) Delete(ConfigMap ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ConfigMap)
}

func (s *configMapSet) Union(set ConfigMapSet) ConfigMapSet {
	if s == nil {
		return set
	}
	return &configMapMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *configMapSet) Difference(set ConfigMapSet) ConfigMapSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &configMapSet{set: newSet}
}

func (s *configMapSet) Intersection(set ConfigMapSet) ConfigMapSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var configMapList []*v1.ConfigMap
	for _, obj := range newSet.List() {
		configMapList = append(configMapList, obj.(*v1.ConfigMap))
	}
	return NewConfigMapSet(configMapList...)
}

func (s *configMapSet) Find(id ezkube.ResourceId) (*v1.ConfigMap, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ConfigMap %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.ConfigMap{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.ConfigMap), nil
}

func (s *configMapSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *configMapSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *configMapSet) Delta(newSet ConfigMapSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *configMapSet) Clone() ConfigMapSet {
	if s == nil {
		return nil
	}
	return &configMapMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type configMapMergedSet struct {
	sets []sksets.ResourceSet
}

func NewConfigMapMergedSet(configMapList ...*v1.ConfigMap) ConfigMapSet {
	return &configMapMergedSet{sets: []sksets.ResourceSet{makeGenericConfigMapSet(configMapList)}}
}

func NewConfigMapMergedSetFromList(configMapList *v1.ConfigMapList) ConfigMapSet {
	list := make([]*v1.ConfigMap, 0, len(configMapList.Items))
	for idx := range configMapList.Items {
		list = append(list, &configMapList.Items[idx])
	}
	return &configMapMergedSet{sets: []sksets.ResourceSet{makeGenericConfigMapSet(list)}}
}

func (s *configMapMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *configMapMergedSet) List(filterResource ...func(*v1.ConfigMap) bool) []*v1.ConfigMap {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ConfigMap))
		})
	}
	configMapList := []*v1.ConfigMap{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			configMapList = append(configMapList, obj.(*v1.ConfigMap))
		}
	}
	return configMapList
}

func (s *configMapMergedSet) UnsortedList(filterResource ...func(*v1.ConfigMap) bool) []*v1.ConfigMap {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.ConfigMap))
		})
	}

	configMapList := []*v1.ConfigMap{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			configMapList = append(configMapList, obj.(*v1.ConfigMap))
		}
	}
	return configMapList
}

func (s *configMapMergedSet) Map() map[string]*v1.ConfigMap {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.ConfigMap{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.ConfigMap)
		}
	}
	return newMap
}

func (s *configMapMergedSet) Insert(
	configMapList ...*v1.ConfigMap,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericConfigMapSet(configMapList))
	}
	for _, obj := range configMapList {
		s.sets[0].Insert(obj)
	}
}

func (s *configMapMergedSet) Has(configMap ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(configMap) {
			return true
		}
	}
	return false
}

func (s *configMapMergedSet) Equal(
	configMapSet ConfigMapSet,
) bool {
	panic("unimplemented")
}

func (s *configMapMergedSet) Delete(ConfigMap ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *configMapMergedSet) Union(set ConfigMapSet) ConfigMapSet {
	return &configMapMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *configMapMergedSet) Difference(set ConfigMapSet) ConfigMapSet {
	panic("unimplemented")
}

func (s *configMapMergedSet) Intersection(set ConfigMapSet) ConfigMapSet {
	panic("unimplemented")
}

func (s *configMapMergedSet) Find(id ezkube.ResourceId) (*v1.ConfigMap, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ConfigMap %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.ConfigMap{}, id)
		if err == nil {
			return obj.(*v1.ConfigMap), nil
		}
	}

	return nil, err
}

func (s *configMapMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *configMapMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *configMapMergedSet) Delta(newSet ConfigMapSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *configMapMergedSet) Clone() ConfigMapSet {
	if s == nil {
		return nil
	}
	return &configMapMergedSet{sets: s.sets[:]}
}

type ServiceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.Service) bool) []*v1.Service
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.Service) bool) []*v1.Service
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.Service
	// Insert a resource into the set.
	Insert(service ...*v1.Service)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(serviceSet ServiceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(service ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(service ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ServiceSet) ServiceSet
	// Return the difference with the provided set
	Difference(set ServiceSet) ServiceSet
	// Return the intersection with the provided set
	Intersection(set ServiceSet) ServiceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.Service, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ServiceSet
	Delta(newSet ServiceSet) sksets.ResourceDelta
	// Create a deep copy of the current ServiceSet
	Clone() ServiceSet
}

func makeGenericServiceSet(serviceList []*v1.Service) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range serviceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceSet struct {
	set sksets.ResourceSet
}

func NewServiceSet(serviceList ...*v1.Service) ServiceSet {
	return &serviceSet{set: makeGenericServiceSet(serviceList)}
}

func NewServiceSetFromList(serviceList *v1.ServiceList) ServiceSet {
	list := make([]*v1.Service, 0, len(serviceList.Items))
	for idx := range serviceList.Items {
		list = append(list, &serviceList.Items[idx])
	}
	return &serviceSet{set: makeGenericServiceSet(list)}
}

func (s *serviceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *serviceSet) List(filterResource ...func(*v1.Service) bool) []*v1.Service {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Service))
		})
	}

	objs := s.Generic().List(genericFilters...)
	serviceList := make([]*v1.Service, 0, len(objs))
	for _, obj := range objs {
		serviceList = append(serviceList, obj.(*v1.Service))
	}
	return serviceList
}

func (s *serviceSet) UnsortedList(filterResource ...func(*v1.Service) bool) []*v1.Service {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Service))
		})
	}

	var serviceList []*v1.Service
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		serviceList = append(serviceList, obj.(*v1.Service))
	}
	return serviceList
}

func (s *serviceSet) Map() map[string]*v1.Service {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Service{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.Service)
	}
	return newMap
}

func (s *serviceSet) Insert(
	serviceList ...*v1.Service,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range serviceList {
		s.Generic().Insert(obj)
	}
}

func (s *serviceSet) Has(service ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(service)
}

func (s *serviceSet) Equal(
	serviceSet ServiceSet,
) bool {
	if s == nil {
		return serviceSet == nil
	}
	return s.Generic().Equal(serviceSet.Generic())
}

func (s *serviceSet) Delete(Service ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Service)
}

func (s *serviceSet) Union(set ServiceSet) ServiceSet {
	if s == nil {
		return set
	}
	return &serviceMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *serviceSet) Difference(set ServiceSet) ServiceSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &serviceSet{set: newSet}
}

func (s *serviceSet) Intersection(set ServiceSet) ServiceSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var serviceList []*v1.Service
	for _, obj := range newSet.List() {
		serviceList = append(serviceList, obj.(*v1.Service))
	}
	return NewServiceSet(serviceList...)
}

func (s *serviceSet) Find(id ezkube.ResourceId) (*v1.Service, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Service %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.Service{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Service), nil
}

func (s *serviceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *serviceSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *serviceSet) Delta(newSet ServiceSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *serviceSet) Clone() ServiceSet {
	if s == nil {
		return nil
	}
	return &serviceMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type serviceMergedSet struct {
	sets []sksets.ResourceSet
}

func NewServiceMergedSet(serviceList ...*v1.Service) ServiceSet {
	return &serviceMergedSet{sets: []sksets.ResourceSet{makeGenericServiceSet(serviceList)}}
}

func NewServiceMergedSetFromList(serviceList *v1.ServiceList) ServiceSet {
	list := make([]*v1.Service, 0, len(serviceList.Items))
	for idx := range serviceList.Items {
		list = append(list, &serviceList.Items[idx])
	}
	return &serviceMergedSet{sets: []sksets.ResourceSet{makeGenericServiceSet(list)}}
}

func (s *serviceMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *serviceMergedSet) List(filterResource ...func(*v1.Service) bool) []*v1.Service {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Service))
		})
	}
	serviceList := []*v1.Service{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			serviceList = append(serviceList, obj.(*v1.Service))
		}
	}
	return serviceList
}

func (s *serviceMergedSet) UnsortedList(filterResource ...func(*v1.Service) bool) []*v1.Service {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Service))
		})
	}

	serviceList := []*v1.Service{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			serviceList = append(serviceList, obj.(*v1.Service))
		}
	}
	return serviceList
}

func (s *serviceMergedSet) Map() map[string]*v1.Service {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Service{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.Service)
		}
	}
	return newMap
}

func (s *serviceMergedSet) Insert(
	serviceList ...*v1.Service,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericServiceSet(serviceList))
	}
	for _, obj := range serviceList {
		s.sets[0].Insert(obj)
	}
}

func (s *serviceMergedSet) Has(service ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(service) {
			return true
		}
	}
	return false
}

func (s *serviceMergedSet) Equal(
	serviceSet ServiceSet,
) bool {
	panic("unimplemented")
}

func (s *serviceMergedSet) Delete(Service ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *serviceMergedSet) Union(set ServiceSet) ServiceSet {
	return &serviceMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *serviceMergedSet) Difference(set ServiceSet) ServiceSet {
	panic("unimplemented")
}

func (s *serviceMergedSet) Intersection(set ServiceSet) ServiceSet {
	panic("unimplemented")
}

func (s *serviceMergedSet) Find(id ezkube.ResourceId) (*v1.Service, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Service %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.Service{}, id)
		if err == nil {
			return obj.(*v1.Service), nil
		}
	}

	return nil, err
}

func (s *serviceMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *serviceMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *serviceMergedSet) Delta(newSet ServiceSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *serviceMergedSet) Clone() ServiceSet {
	if s == nil {
		return nil
	}
	return &serviceMergedSet{sets: s.sets[:]}
}

type PodSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.Pod) bool) []*v1.Pod
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.Pod) bool) []*v1.Pod
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.Pod
	// Insert a resource into the set.
	Insert(pod ...*v1.Pod)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(podSet PodSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(pod ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(pod ezkube.ResourceId)
	// Return the union with the provided set
	Union(set PodSet) PodSet
	// Return the difference with the provided set
	Difference(set PodSet) PodSet
	// Return the intersection with the provided set
	Intersection(set PodSet) PodSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.Pod, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another PodSet
	Delta(newSet PodSet) sksets.ResourceDelta
	// Create a deep copy of the current PodSet
	Clone() PodSet
}

func makeGenericPodSet(podList []*v1.Pod) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range podList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type podSet struct {
	set sksets.ResourceSet
}

func NewPodSet(podList ...*v1.Pod) PodSet {
	return &podSet{set: makeGenericPodSet(podList)}
}

func NewPodSetFromList(podList *v1.PodList) PodSet {
	list := make([]*v1.Pod, 0, len(podList.Items))
	for idx := range podList.Items {
		list = append(list, &podList.Items[idx])
	}
	return &podSet{set: makeGenericPodSet(list)}
}

func (s *podSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *podSet) List(filterResource ...func(*v1.Pod) bool) []*v1.Pod {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Pod))
		})
	}

	objs := s.Generic().List(genericFilters...)
	podList := make([]*v1.Pod, 0, len(objs))
	for _, obj := range objs {
		podList = append(podList, obj.(*v1.Pod))
	}
	return podList
}

func (s *podSet) UnsortedList(filterResource ...func(*v1.Pod) bool) []*v1.Pod {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Pod))
		})
	}

	var podList []*v1.Pod
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		podList = append(podList, obj.(*v1.Pod))
	}
	return podList
}

func (s *podSet) Map() map[string]*v1.Pod {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Pod{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.Pod)
	}
	return newMap
}

func (s *podSet) Insert(
	podList ...*v1.Pod,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range podList {
		s.Generic().Insert(obj)
	}
}

func (s *podSet) Has(pod ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(pod)
}

func (s *podSet) Equal(
	podSet PodSet,
) bool {
	if s == nil {
		return podSet == nil
	}
	return s.Generic().Equal(podSet.Generic())
}

func (s *podSet) Delete(Pod ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Pod)
}

func (s *podSet) Union(set PodSet) PodSet {
	if s == nil {
		return set
	}
	return &podMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *podSet) Difference(set PodSet) PodSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &podSet{set: newSet}
}

func (s *podSet) Intersection(set PodSet) PodSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var podList []*v1.Pod
	for _, obj := range newSet.List() {
		podList = append(podList, obj.(*v1.Pod))
	}
	return NewPodSet(podList...)
}

func (s *podSet) Find(id ezkube.ResourceId) (*v1.Pod, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Pod %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.Pod{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Pod), nil
}

func (s *podSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *podSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *podSet) Delta(newSet PodSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *podSet) Clone() PodSet {
	if s == nil {
		return nil
	}
	return &podMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type podMergedSet struct {
	sets []sksets.ResourceSet
}

func NewPodMergedSet(podList ...*v1.Pod) PodSet {
	return &podMergedSet{sets: []sksets.ResourceSet{makeGenericPodSet(podList)}}
}

func NewPodMergedSetFromList(podList *v1.PodList) PodSet {
	list := make([]*v1.Pod, 0, len(podList.Items))
	for idx := range podList.Items {
		list = append(list, &podList.Items[idx])
	}
	return &podMergedSet{sets: []sksets.ResourceSet{makeGenericPodSet(list)}}
}

func (s *podMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *podMergedSet) List(filterResource ...func(*v1.Pod) bool) []*v1.Pod {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Pod))
		})
	}
	podList := []*v1.Pod{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			podList = append(podList, obj.(*v1.Pod))
		}
	}
	return podList
}

func (s *podMergedSet) UnsortedList(filterResource ...func(*v1.Pod) bool) []*v1.Pod {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Pod))
		})
	}

	podList := []*v1.Pod{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			podList = append(podList, obj.(*v1.Pod))
		}
	}
	return podList
}

func (s *podMergedSet) Map() map[string]*v1.Pod {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Pod{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.Pod)
		}
	}
	return newMap
}

func (s *podMergedSet) Insert(
	podList ...*v1.Pod,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericPodSet(podList))
	}
	for _, obj := range podList {
		s.sets[0].Insert(obj)
	}
}

func (s *podMergedSet) Has(pod ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(pod) {
			return true
		}
	}
	return false
}

func (s *podMergedSet) Equal(
	podSet PodSet,
) bool {
	panic("unimplemented")
}

func (s *podMergedSet) Delete(Pod ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *podMergedSet) Union(set PodSet) PodSet {
	return &podMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *podMergedSet) Difference(set PodSet) PodSet {
	panic("unimplemented")
}

func (s *podMergedSet) Intersection(set PodSet) PodSet {
	panic("unimplemented")
}

func (s *podMergedSet) Find(id ezkube.ResourceId) (*v1.Pod, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Pod %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.Pod{}, id)
		if err == nil {
			return obj.(*v1.Pod), nil
		}
	}

	return nil, err
}

func (s *podMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *podMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *podMergedSet) Delta(newSet PodSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *podMergedSet) Clone() PodSet {
	if s == nil {
		return nil
	}
	return &podMergedSet{sets: s.sets[:]}
}

type EndpointsSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.Endpoints) bool) []*v1.Endpoints
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.Endpoints) bool) []*v1.Endpoints
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.Endpoints
	// Insert a resource into the set.
	Insert(endpoints ...*v1.Endpoints)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(endpointsSet EndpointsSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(endpoints ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(endpoints ezkube.ResourceId)
	// Return the union with the provided set
	Union(set EndpointsSet) EndpointsSet
	// Return the difference with the provided set
	Difference(set EndpointsSet) EndpointsSet
	// Return the intersection with the provided set
	Intersection(set EndpointsSet) EndpointsSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.Endpoints, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another EndpointsSet
	Delta(newSet EndpointsSet) sksets.ResourceDelta
	// Create a deep copy of the current EndpointsSet
	Clone() EndpointsSet
}

func makeGenericEndpointsSet(endpointsList []*v1.Endpoints) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range endpointsList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type endpointsSet struct {
	set sksets.ResourceSet
}

func NewEndpointsSet(endpointsList ...*v1.Endpoints) EndpointsSet {
	return &endpointsSet{set: makeGenericEndpointsSet(endpointsList)}
}

func NewEndpointsSetFromList(endpointsList *v1.EndpointsList) EndpointsSet {
	list := make([]*v1.Endpoints, 0, len(endpointsList.Items))
	for idx := range endpointsList.Items {
		list = append(list, &endpointsList.Items[idx])
	}
	return &endpointsSet{set: makeGenericEndpointsSet(list)}
}

func (s *endpointsSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *endpointsSet) List(filterResource ...func(*v1.Endpoints) bool) []*v1.Endpoints {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Endpoints))
		})
	}

	objs := s.Generic().List(genericFilters...)
	endpointsList := make([]*v1.Endpoints, 0, len(objs))
	for _, obj := range objs {
		endpointsList = append(endpointsList, obj.(*v1.Endpoints))
	}
	return endpointsList
}

func (s *endpointsSet) UnsortedList(filterResource ...func(*v1.Endpoints) bool) []*v1.Endpoints {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Endpoints))
		})
	}

	var endpointsList []*v1.Endpoints
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		endpointsList = append(endpointsList, obj.(*v1.Endpoints))
	}
	return endpointsList
}

func (s *endpointsSet) Map() map[string]*v1.Endpoints {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Endpoints{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.Endpoints)
	}
	return newMap
}

func (s *endpointsSet) Insert(
	endpointsList ...*v1.Endpoints,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range endpointsList {
		s.Generic().Insert(obj)
	}
}

func (s *endpointsSet) Has(endpoints ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(endpoints)
}

func (s *endpointsSet) Equal(
	endpointsSet EndpointsSet,
) bool {
	if s == nil {
		return endpointsSet == nil
	}
	return s.Generic().Equal(endpointsSet.Generic())
}

func (s *endpointsSet) Delete(Endpoints ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Endpoints)
}

func (s *endpointsSet) Union(set EndpointsSet) EndpointsSet {
	if s == nil {
		return set
	}
	return &endpointsMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *endpointsSet) Difference(set EndpointsSet) EndpointsSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &endpointsSet{set: newSet}
}

func (s *endpointsSet) Intersection(set EndpointsSet) EndpointsSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var endpointsList []*v1.Endpoints
	for _, obj := range newSet.List() {
		endpointsList = append(endpointsList, obj.(*v1.Endpoints))
	}
	return NewEndpointsSet(endpointsList...)
}

func (s *endpointsSet) Find(id ezkube.ResourceId) (*v1.Endpoints, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Endpoints %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.Endpoints{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Endpoints), nil
}

func (s *endpointsSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *endpointsSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *endpointsSet) Delta(newSet EndpointsSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *endpointsSet) Clone() EndpointsSet {
	if s == nil {
		return nil
	}
	return &endpointsMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type endpointsMergedSet struct {
	sets []sksets.ResourceSet
}

func NewEndpointsMergedSet(endpointsList ...*v1.Endpoints) EndpointsSet {
	return &endpointsMergedSet{sets: []sksets.ResourceSet{makeGenericEndpointsSet(endpointsList)}}
}

func NewEndpointsMergedSetFromList(endpointsList *v1.EndpointsList) EndpointsSet {
	list := make([]*v1.Endpoints, 0, len(endpointsList.Items))
	for idx := range endpointsList.Items {
		list = append(list, &endpointsList.Items[idx])
	}
	return &endpointsMergedSet{sets: []sksets.ResourceSet{makeGenericEndpointsSet(list)}}
}

func (s *endpointsMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *endpointsMergedSet) List(filterResource ...func(*v1.Endpoints) bool) []*v1.Endpoints {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Endpoints))
		})
	}
	endpointsList := []*v1.Endpoints{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			endpointsList = append(endpointsList, obj.(*v1.Endpoints))
		}
	}
	return endpointsList
}

func (s *endpointsMergedSet) UnsortedList(filterResource ...func(*v1.Endpoints) bool) []*v1.Endpoints {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Endpoints))
		})
	}

	endpointsList := []*v1.Endpoints{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			endpointsList = append(endpointsList, obj.(*v1.Endpoints))
		}
	}
	return endpointsList
}

func (s *endpointsMergedSet) Map() map[string]*v1.Endpoints {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Endpoints{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.Endpoints)
		}
	}
	return newMap
}

func (s *endpointsMergedSet) Insert(
	endpointsList ...*v1.Endpoints,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericEndpointsSet(endpointsList))
	}
	for _, obj := range endpointsList {
		s.sets[0].Insert(obj)
	}
}

func (s *endpointsMergedSet) Has(endpoints ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(endpoints) {
			return true
		}
	}
	return false
}

func (s *endpointsMergedSet) Equal(
	endpointsSet EndpointsSet,
) bool {
	panic("unimplemented")
}

func (s *endpointsMergedSet) Delete(Endpoints ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *endpointsMergedSet) Union(set EndpointsSet) EndpointsSet {
	return &endpointsMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *endpointsMergedSet) Difference(set EndpointsSet) EndpointsSet {
	panic("unimplemented")
}

func (s *endpointsMergedSet) Intersection(set EndpointsSet) EndpointsSet {
	panic("unimplemented")
}

func (s *endpointsMergedSet) Find(id ezkube.ResourceId) (*v1.Endpoints, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Endpoints %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.Endpoints{}, id)
		if err == nil {
			return obj.(*v1.Endpoints), nil
		}
	}

	return nil, err
}

func (s *endpointsMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *endpointsMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *endpointsMergedSet) Delta(newSet EndpointsSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *endpointsMergedSet) Clone() EndpointsSet {
	if s == nil {
		return nil
	}
	return &endpointsMergedSet{sets: s.sets[:]}
}

type NamespaceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.Namespace) bool) []*v1.Namespace
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.Namespace) bool) []*v1.Namespace
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.Namespace
	// Insert a resource into the set.
	Insert(namespace ...*v1.Namespace)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(namespaceSet NamespaceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(namespace ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(namespace ezkube.ResourceId)
	// Return the union with the provided set
	Union(set NamespaceSet) NamespaceSet
	// Return the difference with the provided set
	Difference(set NamespaceSet) NamespaceSet
	// Return the intersection with the provided set
	Intersection(set NamespaceSet) NamespaceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.Namespace, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another NamespaceSet
	Delta(newSet NamespaceSet) sksets.ResourceDelta
	// Create a deep copy of the current NamespaceSet
	Clone() NamespaceSet
}

func makeGenericNamespaceSet(namespaceList []*v1.Namespace) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range namespaceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type namespaceSet struct {
	set sksets.ResourceSet
}

func NewNamespaceSet(namespaceList ...*v1.Namespace) NamespaceSet {
	return &namespaceSet{set: makeGenericNamespaceSet(namespaceList)}
}

func NewNamespaceSetFromList(namespaceList *v1.NamespaceList) NamespaceSet {
	list := make([]*v1.Namespace, 0, len(namespaceList.Items))
	for idx := range namespaceList.Items {
		list = append(list, &namespaceList.Items[idx])
	}
	return &namespaceSet{set: makeGenericNamespaceSet(list)}
}

func (s *namespaceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *namespaceSet) List(filterResource ...func(*v1.Namespace) bool) []*v1.Namespace {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Namespace))
		})
	}

	objs := s.Generic().List(genericFilters...)
	namespaceList := make([]*v1.Namespace, 0, len(objs))
	for _, obj := range objs {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return namespaceList
}

func (s *namespaceSet) UnsortedList(filterResource ...func(*v1.Namespace) bool) []*v1.Namespace {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Namespace))
		})
	}

	var namespaceList []*v1.Namespace
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return namespaceList
}

func (s *namespaceSet) Map() map[string]*v1.Namespace {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Namespace{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.Namespace)
	}
	return newMap
}

func (s *namespaceSet) Insert(
	namespaceList ...*v1.Namespace,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range namespaceList {
		s.Generic().Insert(obj)
	}
}

func (s *namespaceSet) Has(namespace ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(namespace)
}

func (s *namespaceSet) Equal(
	namespaceSet NamespaceSet,
) bool {
	if s == nil {
		return namespaceSet == nil
	}
	return s.Generic().Equal(namespaceSet.Generic())
}

func (s *namespaceSet) Delete(Namespace ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Namespace)
}

func (s *namespaceSet) Union(set NamespaceSet) NamespaceSet {
	if s == nil {
		return set
	}
	return &namespaceMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *namespaceSet) Difference(set NamespaceSet) NamespaceSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &namespaceSet{set: newSet}
}

func (s *namespaceSet) Intersection(set NamespaceSet) NamespaceSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var namespaceList []*v1.Namespace
	for _, obj := range newSet.List() {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return NewNamespaceSet(namespaceList...)
}

func (s *namespaceSet) Find(id ezkube.ResourceId) (*v1.Namespace, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Namespace %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.Namespace{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Namespace), nil
}

func (s *namespaceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *namespaceSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *namespaceSet) Delta(newSet NamespaceSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *namespaceSet) Clone() NamespaceSet {
	if s == nil {
		return nil
	}
	return &namespaceMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type namespaceMergedSet struct {
	sets []sksets.ResourceSet
}

func NewNamespaceMergedSet(namespaceList ...*v1.Namespace) NamespaceSet {
	return &namespaceMergedSet{sets: []sksets.ResourceSet{makeGenericNamespaceSet(namespaceList)}}
}

func NewNamespaceMergedSetFromList(namespaceList *v1.NamespaceList) NamespaceSet {
	list := make([]*v1.Namespace, 0, len(namespaceList.Items))
	for idx := range namespaceList.Items {
		list = append(list, &namespaceList.Items[idx])
	}
	return &namespaceMergedSet{sets: []sksets.ResourceSet{makeGenericNamespaceSet(list)}}
}

func (s *namespaceMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *namespaceMergedSet) List(filterResource ...func(*v1.Namespace) bool) []*v1.Namespace {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Namespace))
		})
	}
	namespaceList := []*v1.Namespace{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			namespaceList = append(namespaceList, obj.(*v1.Namespace))
		}
	}
	return namespaceList
}

func (s *namespaceMergedSet) UnsortedList(filterResource ...func(*v1.Namespace) bool) []*v1.Namespace {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Namespace))
		})
	}

	namespaceList := []*v1.Namespace{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			namespaceList = append(namespaceList, obj.(*v1.Namespace))
		}
	}
	return namespaceList
}

func (s *namespaceMergedSet) Map() map[string]*v1.Namespace {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Namespace{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.Namespace)
		}
	}
	return newMap
}

func (s *namespaceMergedSet) Insert(
	namespaceList ...*v1.Namespace,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericNamespaceSet(namespaceList))
	}
	for _, obj := range namespaceList {
		s.sets[0].Insert(obj)
	}
}

func (s *namespaceMergedSet) Has(namespace ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(namespace) {
			return true
		}
	}
	return false
}

func (s *namespaceMergedSet) Equal(
	namespaceSet NamespaceSet,
) bool {
	panic("unimplemented")
}

func (s *namespaceMergedSet) Delete(Namespace ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *namespaceMergedSet) Union(set NamespaceSet) NamespaceSet {
	return &namespaceMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *namespaceMergedSet) Difference(set NamespaceSet) NamespaceSet {
	panic("unimplemented")
}

func (s *namespaceMergedSet) Intersection(set NamespaceSet) NamespaceSet {
	panic("unimplemented")
}

func (s *namespaceMergedSet) Find(id ezkube.ResourceId) (*v1.Namespace, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Namespace %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.Namespace{}, id)
		if err == nil {
			return obj.(*v1.Namespace), nil
		}
	}

	return nil, err
}

func (s *namespaceMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *namespaceMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *namespaceMergedSet) Delta(newSet NamespaceSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *namespaceMergedSet) Clone() NamespaceSet {
	if s == nil {
		return nil
	}
	return &namespaceMergedSet{sets: s.sets[:]}
}

type NodeSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*v1.Node) bool) []*v1.Node
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*v1.Node) bool) []*v1.Node
	// Return the Set as a map of key to resource.
	Map() map[string]*v1.Node
	// Insert a resource into the set.
	Insert(node ...*v1.Node)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(nodeSet NodeSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(node ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(node ezkube.ResourceId)
	// Return the union with the provided set
	Union(set NodeSet) NodeSet
	// Return the difference with the provided set
	Difference(set NodeSet) NodeSet
	// Return the intersection with the provided set
	Intersection(set NodeSet) NodeSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*v1.Node, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another NodeSet
	Delta(newSet NodeSet) sksets.ResourceDelta
	// Create a deep copy of the current NodeSet
	Clone() NodeSet
}

func makeGenericNodeSet(nodeList []*v1.Node) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range nodeList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type nodeSet struct {
	set sksets.ResourceSet
}

func NewNodeSet(nodeList ...*v1.Node) NodeSet {
	return &nodeSet{set: makeGenericNodeSet(nodeList)}
}

func NewNodeSetFromList(nodeList *v1.NodeList) NodeSet {
	list := make([]*v1.Node, 0, len(nodeList.Items))
	for idx := range nodeList.Items {
		list = append(list, &nodeList.Items[idx])
	}
	return &nodeSet{set: makeGenericNodeSet(list)}
}

func (s *nodeSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *nodeSet) List(filterResource ...func(*v1.Node) bool) []*v1.Node {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Node))
		})
	}

	objs := s.Generic().List(genericFilters...)
	nodeList := make([]*v1.Node, 0, len(objs))
	for _, obj := range objs {
		nodeList = append(nodeList, obj.(*v1.Node))
	}
	return nodeList
}

func (s *nodeSet) UnsortedList(filterResource ...func(*v1.Node) bool) []*v1.Node {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Node))
		})
	}

	var nodeList []*v1.Node
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		nodeList = append(nodeList, obj.(*v1.Node))
	}
	return nodeList
}

func (s *nodeSet) Map() map[string]*v1.Node {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Node{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*v1.Node)
	}
	return newMap
}

func (s *nodeSet) Insert(
	nodeList ...*v1.Node,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range nodeList {
		s.Generic().Insert(obj)
	}
}

func (s *nodeSet) Has(node ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(node)
}

func (s *nodeSet) Equal(
	nodeSet NodeSet,
) bool {
	if s == nil {
		return nodeSet == nil
	}
	return s.Generic().Equal(nodeSet.Generic())
}

func (s *nodeSet) Delete(Node ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Node)
}

func (s *nodeSet) Union(set NodeSet) NodeSet {
	if s == nil {
		return set
	}
	return &nodeMergedSet{sets: []sksets.ResourceSet{s.Generic(), set.Generic()}}
}

func (s *nodeSet) Difference(set NodeSet) NodeSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &nodeSet{set: newSet}
}

func (s *nodeSet) Intersection(set NodeSet) NodeSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var nodeList []*v1.Node
	for _, obj := range newSet.List() {
		nodeList = append(nodeList, obj.(*v1.Node))
	}
	return NewNodeSet(nodeList...)
}

func (s *nodeSet) Find(id ezkube.ResourceId) (*v1.Node, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Node %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&v1.Node{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Node), nil
}

func (s *nodeSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *nodeSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *nodeSet) Delta(newSet NodeSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *nodeSet) Clone() NodeSet {
	if s == nil {
		return nil
	}
	return &nodeMergedSet{sets: []sksets.ResourceSet{s.Generic()}}
}

type nodeMergedSet struct {
	sets []sksets.ResourceSet
}

func NewNodeMergedSet(nodeList ...*v1.Node) NodeSet {
	return &nodeMergedSet{sets: []sksets.ResourceSet{makeGenericNodeSet(nodeList)}}
}

func NewNodeMergedSetFromList(nodeList *v1.NodeList) NodeSet {
	list := make([]*v1.Node, 0, len(nodeList.Items))
	for idx := range nodeList.Items {
		list = append(list, &nodeList.Items[idx])
	}
	return &nodeMergedSet{sets: []sksets.ResourceSet{makeGenericNodeSet(list)}}
}

func (s *nodeMergedSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	toRet := sets.String{}
	for _, set := range s.sets {
		toRet = toRet.Union(set.Keys())
	}
	return toRet
}

func (s *nodeMergedSet) List(filterResource ...func(*v1.Node) bool) []*v1.Node {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Node))
		})
	}
	nodeList := []*v1.Node{}
	for _, set := range s.sets {
		for _, obj := range set.List(genericFilters...) {
			nodeList = append(nodeList, obj.(*v1.Node))
		}
	}
	return nodeList
}

func (s *nodeMergedSet) UnsortedList(filterResource ...func(*v1.Node) bool) []*v1.Node {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*v1.Node))
		})
	}

	nodeList := []*v1.Node{}
	for _, set := range s.sets {
		for _, obj := range set.UnsortedList(genericFilters...) {
			nodeList = append(nodeList, obj.(*v1.Node))
		}
	}
	return nodeList
}

func (s *nodeMergedSet) Map() map[string]*v1.Node {
	if s == nil {
		return nil
	}

	newMap := map[string]*v1.Node{}
	for _, set := range s.sets {
		for k, v := range set.Map() {
			newMap[k] = v.(*v1.Node)
		}
	}
	return newMap
}

func (s *nodeMergedSet) Insert(
	nodeList ...*v1.Node,
) {
	if s == nil {
	}
	if len(s.sets) == 0 {
		s.sets = append(s.sets, makeGenericNodeSet(nodeList))
	}
	for _, obj := range nodeList {
		s.sets[0].Insert(obj)
	}
}

func (s *nodeMergedSet) Has(node ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	for _, set := range s.sets {
		if set.Has(node) {
			return true
		}
	}
	return false
}

func (s *nodeMergedSet) Equal(
	nodeSet NodeSet,
) bool {
	panic("unimplemented")
}

func (s *nodeMergedSet) Delete(Node ezkube.ResourceId) {
	panic("unimplemented")
}

func (s *nodeMergedSet) Union(set NodeSet) NodeSet {
	return &nodeMergedSet{sets: append(s.sets, set.Generic())}
}

func (s *nodeMergedSet) Difference(set NodeSet) NodeSet {
	panic("unimplemented")
}

func (s *nodeMergedSet) Intersection(set NodeSet) NodeSet {
	panic("unimplemented")
}

func (s *nodeMergedSet) Find(id ezkube.ResourceId) (*v1.Node, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Node %v", sksets.Key(id))
	}

	var err error
	for _, set := range s.sets {
		var obj ezkube.ResourceId
		obj, err = set.Find(&v1.Node{}, id)
		if err == nil {
			return obj.(*v1.Node), nil
		}
	}

	return nil, err
}

func (s *nodeMergedSet) Length() int {
	if s == nil {
		return 0
	}
	totalLen := 0
	for _, set := range s.sets {
		totalLen += set.Length()
	}
	return totalLen
}

func (s *nodeMergedSet) Generic() sksets.ResourceSet {
	panic("unimplemented")
}

func (s *nodeMergedSet) Delta(newSet NodeSet) sksets.ResourceDelta {
	panic("unimplemented")
}

func (s *nodeMergedSet) Clone() NodeSet {
	if s == nil {
		return nil
	}
	return &nodeMergedSet{sets: s.sets[:]}
}
