// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	v1 "k8s.io/api/core/v1"

	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type SecretSet interface {
	Keys() sets.String
	List() []*v1.Secret
	Map() map[string]*v1.Secret
	Insert(secret ...*v1.Secret)
	Equal(secretSet SecretSet) bool
	Has(secret *v1.Secret) bool
	Delete(secret *v1.Secret)
	Union(set SecretSet) SecretSet
	Difference(set SecretSet) SecretSet
	Intersection(set SecretSet) SecretSet
	Find(id ezkube.ResourceId) (*v1.Secret, error)
}

func makeGenericSecretSet(secretList []*v1.Secret) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range secretList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type secretSet struct {
	set sksets.ResourceSet
}

func NewSecretSet(secretList ...*v1.Secret) SecretSet {
	return &secretSet{set: makeGenericSecretSet(secretList)}
}

func (s secretSet) Keys() sets.String {
	return s.set.Keys()
}

func (s secretSet) List() []*v1.Secret {
	var secretList []*v1.Secret
	for _, obj := range s.set.List() {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return secretList
}

func (s secretSet) Map() map[string]*v1.Secret {
	newMap := map[string]*v1.Secret{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Secret)
	}
	return newMap
}

func (s secretSet) Insert(
	secretList ...*v1.Secret,
) {
	for _, obj := range secretList {
		s.set.Insert(obj)
	}
}

func (s secretSet) Has(secret *v1.Secret) bool {
	return s.set.Has(secret)
}

func (s secretSet) Equal(
	secretSet SecretSet,
) bool {
	return s.set.Equal(makeGenericSecretSet(secretSet.List()))
}

func (s secretSet) Delete(Secret *v1.Secret) {
	s.set.Delete(Secret)
}

func (s secretSet) Union(set SecretSet) SecretSet {
	return NewSecretSet(append(s.List(), set.List()...)...)
}

func (s secretSet) Difference(set SecretSet) SecretSet {
	newSet := s.set.Difference(makeGenericSecretSet(set.List()))
	return secretSet{set: newSet}
}

func (s secretSet) Intersection(set SecretSet) SecretSet {
	newSet := s.set.Intersection(makeGenericSecretSet(set.List()))
	var secretList []*v1.Secret
	for _, obj := range newSet.List() {
		secretList = append(secretList, obj.(*v1.Secret))
	}
	return NewSecretSet(secretList...)
}

func (s secretSet) Find(id ezkube.ResourceId) (*v1.Secret, error) {
	obj, err := s.set.Find(&v1.Secret{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Secret), nil
}

type ServiceAccountSet interface {
	Keys() sets.String
	List() []*v1.ServiceAccount
	Map() map[string]*v1.ServiceAccount
	Insert(serviceAccount ...*v1.ServiceAccount)
	Equal(serviceAccountSet ServiceAccountSet) bool
	Has(serviceAccount *v1.ServiceAccount) bool
	Delete(serviceAccount *v1.ServiceAccount)
	Union(set ServiceAccountSet) ServiceAccountSet
	Difference(set ServiceAccountSet) ServiceAccountSet
	Intersection(set ServiceAccountSet) ServiceAccountSet
	Find(id ezkube.ResourceId) (*v1.ServiceAccount, error)
}

func makeGenericServiceAccountSet(serviceAccountList []*v1.ServiceAccount) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range serviceAccountList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceAccountSet struct {
	set sksets.ResourceSet
}

func NewServiceAccountSet(serviceAccountList ...*v1.ServiceAccount) ServiceAccountSet {
	return &serviceAccountSet{set: makeGenericServiceAccountSet(serviceAccountList)}
}

func (s serviceAccountSet) Keys() sets.String {
	return s.set.Keys()
}

func (s serviceAccountSet) List() []*v1.ServiceAccount {
	var serviceAccountList []*v1.ServiceAccount
	for _, obj := range s.set.List() {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return serviceAccountList
}

func (s serviceAccountSet) Map() map[string]*v1.ServiceAccount {
	newMap := map[string]*v1.ServiceAccount{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.ServiceAccount)
	}
	return newMap
}

func (s serviceAccountSet) Insert(
	serviceAccountList ...*v1.ServiceAccount,
) {
	for _, obj := range serviceAccountList {
		s.set.Insert(obj)
	}
}

func (s serviceAccountSet) Has(serviceAccount *v1.ServiceAccount) bool {
	return s.set.Has(serviceAccount)
}

func (s serviceAccountSet) Equal(
	serviceAccountSet ServiceAccountSet,
) bool {
	return s.set.Equal(makeGenericServiceAccountSet(serviceAccountSet.List()))
}

func (s serviceAccountSet) Delete(ServiceAccount *v1.ServiceAccount) {
	s.set.Delete(ServiceAccount)
}

func (s serviceAccountSet) Union(set ServiceAccountSet) ServiceAccountSet {
	return NewServiceAccountSet(append(s.List(), set.List()...)...)
}

func (s serviceAccountSet) Difference(set ServiceAccountSet) ServiceAccountSet {
	newSet := s.set.Difference(makeGenericServiceAccountSet(set.List()))
	return serviceAccountSet{set: newSet}
}

func (s serviceAccountSet) Intersection(set ServiceAccountSet) ServiceAccountSet {
	newSet := s.set.Intersection(makeGenericServiceAccountSet(set.List()))
	var serviceAccountList []*v1.ServiceAccount
	for _, obj := range newSet.List() {
		serviceAccountList = append(serviceAccountList, obj.(*v1.ServiceAccount))
	}
	return NewServiceAccountSet(serviceAccountList...)
}

func (s serviceAccountSet) Find(id ezkube.ResourceId) (*v1.ServiceAccount, error) {
	obj, err := s.set.Find(&v1.ServiceAccount{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.ServiceAccount), nil
}

type ConfigMapSet interface {
	Keys() sets.String
	List() []*v1.ConfigMap
	Map() map[string]*v1.ConfigMap
	Insert(configMap ...*v1.ConfigMap)
	Equal(configMapSet ConfigMapSet) bool
	Has(configMap *v1.ConfigMap) bool
	Delete(configMap *v1.ConfigMap)
	Union(set ConfigMapSet) ConfigMapSet
	Difference(set ConfigMapSet) ConfigMapSet
	Intersection(set ConfigMapSet) ConfigMapSet
	Find(id ezkube.ResourceId) (*v1.ConfigMap, error)
}

func makeGenericConfigMapSet(configMapList []*v1.ConfigMap) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range configMapList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type configMapSet struct {
	set sksets.ResourceSet
}

func NewConfigMapSet(configMapList ...*v1.ConfigMap) ConfigMapSet {
	return &configMapSet{set: makeGenericConfigMapSet(configMapList)}
}

func (s configMapSet) Keys() sets.String {
	return s.set.Keys()
}

func (s configMapSet) List() []*v1.ConfigMap {
	var configMapList []*v1.ConfigMap
	for _, obj := range s.set.List() {
		configMapList = append(configMapList, obj.(*v1.ConfigMap))
	}
	return configMapList
}

func (s configMapSet) Map() map[string]*v1.ConfigMap {
	newMap := map[string]*v1.ConfigMap{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.ConfigMap)
	}
	return newMap
}

func (s configMapSet) Insert(
	configMapList ...*v1.ConfigMap,
) {
	for _, obj := range configMapList {
		s.set.Insert(obj)
	}
}

func (s configMapSet) Has(configMap *v1.ConfigMap) bool {
	return s.set.Has(configMap)
}

func (s configMapSet) Equal(
	configMapSet ConfigMapSet,
) bool {
	return s.set.Equal(makeGenericConfigMapSet(configMapSet.List()))
}

func (s configMapSet) Delete(ConfigMap *v1.ConfigMap) {
	s.set.Delete(ConfigMap)
}

func (s configMapSet) Union(set ConfigMapSet) ConfigMapSet {
	return NewConfigMapSet(append(s.List(), set.List()...)...)
}

func (s configMapSet) Difference(set ConfigMapSet) ConfigMapSet {
	newSet := s.set.Difference(makeGenericConfigMapSet(set.List()))
	return configMapSet{set: newSet}
}

func (s configMapSet) Intersection(set ConfigMapSet) ConfigMapSet {
	newSet := s.set.Intersection(makeGenericConfigMapSet(set.List()))
	var configMapList []*v1.ConfigMap
	for _, obj := range newSet.List() {
		configMapList = append(configMapList, obj.(*v1.ConfigMap))
	}
	return NewConfigMapSet(configMapList...)
}

func (s configMapSet) Find(id ezkube.ResourceId) (*v1.ConfigMap, error) {
	obj, err := s.set.Find(&v1.ConfigMap{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.ConfigMap), nil
}

type ServiceSet interface {
	Keys() sets.String
	List() []*v1.Service
	Map() map[string]*v1.Service
	Insert(service ...*v1.Service)
	Equal(serviceSet ServiceSet) bool
	Has(service *v1.Service) bool
	Delete(service *v1.Service)
	Union(set ServiceSet) ServiceSet
	Difference(set ServiceSet) ServiceSet
	Intersection(set ServiceSet) ServiceSet
	Find(id ezkube.ResourceId) (*v1.Service, error)
}

func makeGenericServiceSet(serviceList []*v1.Service) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range serviceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type serviceSet struct {
	set sksets.ResourceSet
}

func NewServiceSet(serviceList ...*v1.Service) ServiceSet {
	return &serviceSet{set: makeGenericServiceSet(serviceList)}
}

func (s serviceSet) Keys() sets.String {
	return s.set.Keys()
}

func (s serviceSet) List() []*v1.Service {
	var serviceList []*v1.Service
	for _, obj := range s.set.List() {
		serviceList = append(serviceList, obj.(*v1.Service))
	}
	return serviceList
}

func (s serviceSet) Map() map[string]*v1.Service {
	newMap := map[string]*v1.Service{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Service)
	}
	return newMap
}

func (s serviceSet) Insert(
	serviceList ...*v1.Service,
) {
	for _, obj := range serviceList {
		s.set.Insert(obj)
	}
}

func (s serviceSet) Has(service *v1.Service) bool {
	return s.set.Has(service)
}

func (s serviceSet) Equal(
	serviceSet ServiceSet,
) bool {
	return s.set.Equal(makeGenericServiceSet(serviceSet.List()))
}

func (s serviceSet) Delete(Service *v1.Service) {
	s.set.Delete(Service)
}

func (s serviceSet) Union(set ServiceSet) ServiceSet {
	return NewServiceSet(append(s.List(), set.List()...)...)
}

func (s serviceSet) Difference(set ServiceSet) ServiceSet {
	newSet := s.set.Difference(makeGenericServiceSet(set.List()))
	return serviceSet{set: newSet}
}

func (s serviceSet) Intersection(set ServiceSet) ServiceSet {
	newSet := s.set.Intersection(makeGenericServiceSet(set.List()))
	var serviceList []*v1.Service
	for _, obj := range newSet.List() {
		serviceList = append(serviceList, obj.(*v1.Service))
	}
	return NewServiceSet(serviceList...)
}

func (s serviceSet) Find(id ezkube.ResourceId) (*v1.Service, error) {
	obj, err := s.set.Find(&v1.Service{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Service), nil
}

type PodSet interface {
	Keys() sets.String
	List() []*v1.Pod
	Map() map[string]*v1.Pod
	Insert(pod ...*v1.Pod)
	Equal(podSet PodSet) bool
	Has(pod *v1.Pod) bool
	Delete(pod *v1.Pod)
	Union(set PodSet) PodSet
	Difference(set PodSet) PodSet
	Intersection(set PodSet) PodSet
	Find(id ezkube.ResourceId) (*v1.Pod, error)
}

func makeGenericPodSet(podList []*v1.Pod) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range podList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type podSet struct {
	set sksets.ResourceSet
}

func NewPodSet(podList ...*v1.Pod) PodSet {
	return &podSet{set: makeGenericPodSet(podList)}
}

func (s podSet) Keys() sets.String {
	return s.set.Keys()
}

func (s podSet) List() []*v1.Pod {
	var podList []*v1.Pod
	for _, obj := range s.set.List() {
		podList = append(podList, obj.(*v1.Pod))
	}
	return podList
}

func (s podSet) Map() map[string]*v1.Pod {
	newMap := map[string]*v1.Pod{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Pod)
	}
	return newMap
}

func (s podSet) Insert(
	podList ...*v1.Pod,
) {
	for _, obj := range podList {
		s.set.Insert(obj)
	}
}

func (s podSet) Has(pod *v1.Pod) bool {
	return s.set.Has(pod)
}

func (s podSet) Equal(
	podSet PodSet,
) bool {
	return s.set.Equal(makeGenericPodSet(podSet.List()))
}

func (s podSet) Delete(Pod *v1.Pod) {
	s.set.Delete(Pod)
}

func (s podSet) Union(set PodSet) PodSet {
	return NewPodSet(append(s.List(), set.List()...)...)
}

func (s podSet) Difference(set PodSet) PodSet {
	newSet := s.set.Difference(makeGenericPodSet(set.List()))
	return podSet{set: newSet}
}

func (s podSet) Intersection(set PodSet) PodSet {
	newSet := s.set.Intersection(makeGenericPodSet(set.List()))
	var podList []*v1.Pod
	for _, obj := range newSet.List() {
		podList = append(podList, obj.(*v1.Pod))
	}
	return NewPodSet(podList...)
}

func (s podSet) Find(id ezkube.ResourceId) (*v1.Pod, error) {
	obj, err := s.set.Find(&v1.Pod{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Pod), nil
}

type NamespaceSet interface {
	Keys() sets.String
	List() []*v1.Namespace
	Map() map[string]*v1.Namespace
	Insert(namespace ...*v1.Namespace)
	Equal(namespaceSet NamespaceSet) bool
	Has(namespace *v1.Namespace) bool
	Delete(namespace *v1.Namespace)
	Union(set NamespaceSet) NamespaceSet
	Difference(set NamespaceSet) NamespaceSet
	Intersection(set NamespaceSet) NamespaceSet
	Find(id ezkube.ResourceId) (*v1.Namespace, error)
}

func makeGenericNamespaceSet(namespaceList []*v1.Namespace) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range namespaceList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type namespaceSet struct {
	set sksets.ResourceSet
}

func NewNamespaceSet(namespaceList ...*v1.Namespace) NamespaceSet {
	return &namespaceSet{set: makeGenericNamespaceSet(namespaceList)}
}

func (s namespaceSet) Keys() sets.String {
	return s.set.Keys()
}

func (s namespaceSet) List() []*v1.Namespace {
	var namespaceList []*v1.Namespace
	for _, obj := range s.set.List() {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return namespaceList
}

func (s namespaceSet) Map() map[string]*v1.Namespace {
	newMap := map[string]*v1.Namespace{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Namespace)
	}
	return newMap
}

func (s namespaceSet) Insert(
	namespaceList ...*v1.Namespace,
) {
	for _, obj := range namespaceList {
		s.set.Insert(obj)
	}
}

func (s namespaceSet) Has(namespace *v1.Namespace) bool {
	return s.set.Has(namespace)
}

func (s namespaceSet) Equal(
	namespaceSet NamespaceSet,
) bool {
	return s.set.Equal(makeGenericNamespaceSet(namespaceSet.List()))
}

func (s namespaceSet) Delete(Namespace *v1.Namespace) {
	s.set.Delete(Namespace)
}

func (s namespaceSet) Union(set NamespaceSet) NamespaceSet {
	return NewNamespaceSet(append(s.List(), set.List()...)...)
}

func (s namespaceSet) Difference(set NamespaceSet) NamespaceSet {
	newSet := s.set.Difference(makeGenericNamespaceSet(set.List()))
	return namespaceSet{set: newSet}
}

func (s namespaceSet) Intersection(set NamespaceSet) NamespaceSet {
	newSet := s.set.Intersection(makeGenericNamespaceSet(set.List()))
	var namespaceList []*v1.Namespace
	for _, obj := range newSet.List() {
		namespaceList = append(namespaceList, obj.(*v1.Namespace))
	}
	return NewNamespaceSet(namespaceList...)
}

func (s namespaceSet) Find(id ezkube.ResourceId) (*v1.Namespace, error) {
	obj, err := s.set.Find(&v1.Namespace{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Namespace), nil
}

type NodeSet interface {
	Keys() sets.String
	List() []*v1.Node
	Map() map[string]*v1.Node
	Insert(node ...*v1.Node)
	Equal(nodeSet NodeSet) bool
	Has(node *v1.Node) bool
	Delete(node *v1.Node)
	Union(set NodeSet) NodeSet
	Difference(set NodeSet) NodeSet
	Intersection(set NodeSet) NodeSet
	Find(id ezkube.ResourceId) (*v1.Node, error)
}

func makeGenericNodeSet(nodeList []*v1.Node) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range nodeList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type nodeSet struct {
	set sksets.ResourceSet
}

func NewNodeSet(nodeList ...*v1.Node) NodeSet {
	return &nodeSet{set: makeGenericNodeSet(nodeList)}
}

func (s nodeSet) Keys() sets.String {
	return s.set.Keys()
}

func (s nodeSet) List() []*v1.Node {
	var nodeList []*v1.Node
	for _, obj := range s.set.List() {
		nodeList = append(nodeList, obj.(*v1.Node))
	}
	return nodeList
}

func (s nodeSet) Map() map[string]*v1.Node {
	newMap := map[string]*v1.Node{}
	for k, v := range s.set.Map() {
		newMap[k] = v.(*v1.Node)
	}
	return newMap
}

func (s nodeSet) Insert(
	nodeList ...*v1.Node,
) {
	for _, obj := range nodeList {
		s.set.Insert(obj)
	}
}

func (s nodeSet) Has(node *v1.Node) bool {
	return s.set.Has(node)
}

func (s nodeSet) Equal(
	nodeSet NodeSet,
) bool {
	return s.set.Equal(makeGenericNodeSet(nodeSet.List()))
}

func (s nodeSet) Delete(Node *v1.Node) {
	s.set.Delete(Node)
}

func (s nodeSet) Union(set NodeSet) NodeSet {
	return NewNodeSet(append(s.List(), set.List()...)...)
}

func (s nodeSet) Difference(set NodeSet) NodeSet {
	newSet := s.set.Difference(makeGenericNodeSet(set.List()))
	return nodeSet{set: newSet}
}

func (s nodeSet) Intersection(set NodeSet) NodeSet {
	newSet := s.set.Intersection(makeGenericNodeSet(set.List()))
	var nodeList []*v1.Node
	for _, obj := range newSet.List() {
		nodeList = append(nodeList, obj.(*v1.Node))
	}
	return NewNodeSet(nodeList...)
}

func (s nodeSet) Find(id ezkube.ResourceId) (*v1.Node, error) {
	obj, err := s.set.Find(&v1.Node{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*v1.Node), nil
}
