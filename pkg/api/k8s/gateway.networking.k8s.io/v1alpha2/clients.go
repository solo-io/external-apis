// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./clients.go -destination mocks/clients.go

package v1alpha2

import (
	"context"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
	gateway_networking_k8s_io_v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
)

// MulticlusterClientset for the gateway.networking.k8s.io/v1alpha2 APIs
type MulticlusterClientset interface {
	// Cluster returns a Clientset for the given cluster
	Cluster(cluster string) (Clientset, error)
}

type multiclusterClientset struct {
	client multicluster.Client
}

func NewMulticlusterClientset(client multicluster.Client) MulticlusterClientset {
	return &multiclusterClientset{client: client}
}

func (m *multiclusterClientset) Cluster(cluster string) (Clientset, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

// clienset for the gateway.networking.k8s.io/v1alpha2 APIs
type Clientset interface {
	// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
	ReferenceGrants() ReferenceGrantClient
	// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
	GRPCRoutes() GRPCRouteClient
	// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
	TCPRoutes() TCPRouteClient
	// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
	TLSRoutes() TLSRouteClient
	// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
	UDPRoutes() UDPRouteClient
}

type clientSet struct {
	client client.Client
}

func NewClientsetFromConfig(cfg *rest.Config) (Clientset, error) {
	scheme := scheme.Scheme
	if err := gateway_networking_k8s_io_v1alpha2.SchemeBuilder.AddToScheme(scheme); err != nil {
		return nil, err
	}
	client, err := client.New(cfg, client.Options{
		Scheme: scheme,
	})
	if err != nil {
		return nil, err
	}
	return NewClientset(client), nil
}

func NewClientset(client client.Client) Clientset {
	return &clientSet{client: client}
}

// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
func (c *clientSet) ReferenceGrants() ReferenceGrantClient {
	return NewReferenceGrantClient(c.client)
}

// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
func (c *clientSet) GRPCRoutes() GRPCRouteClient {
	return NewGRPCRouteClient(c.client)
}

// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
func (c *clientSet) TCPRoutes() TCPRouteClient {
	return NewTCPRouteClient(c.client)
}

// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
func (c *clientSet) TLSRoutes() TLSRouteClient {
	return NewTLSRouteClient(c.client)
}

// clienset for the gateway.networking.k8s.io/v1alpha2/v1alpha2 APIs
func (c *clientSet) UDPRoutes() UDPRouteClient {
	return NewUDPRouteClient(c.client)
}

// Reader knows how to read and list ReferenceGrants.
type ReferenceGrantReader interface {
	// Get retrieves a ReferenceGrant for the given object key
	GetReferenceGrant(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.ReferenceGrant, error)

	// List retrieves list of ReferenceGrants for a given namespace and list options.
	ListReferenceGrant(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.ReferenceGrantList, error)
}

// ReferenceGrantTransitionFunction instructs the ReferenceGrantWriter how to transition between an existing
// ReferenceGrant object and a desired on an Upsert
type ReferenceGrantTransitionFunction func(existing, desired *gateway_networking_k8s_io_v1alpha2.ReferenceGrant) error

// Writer knows how to create, delete, and update ReferenceGrants.
type ReferenceGrantWriter interface {
	// Create saves the ReferenceGrant object.
	CreateReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, opts ...client.CreateOption) error

	// Delete deletes the ReferenceGrant object.
	DeleteReferenceGrant(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given ReferenceGrant object.
	UpdateReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, opts ...client.UpdateOption) error

	// Patch patches the given ReferenceGrant object.
	PatchReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all ReferenceGrant objects matching the given options.
	DeleteAllOfReferenceGrant(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the ReferenceGrant object.
	UpsertReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, transitionFuncs ...ReferenceGrantTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a ReferenceGrant object.
type ReferenceGrantStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given ReferenceGrant object.
	UpdateReferenceGrantStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given ReferenceGrant object's subresource.
	PatchReferenceGrantStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on ReferenceGrants.
type ReferenceGrantClient interface {
	ReferenceGrantReader
	ReferenceGrantWriter
	ReferenceGrantStatusWriter
}

type referenceGrantClient struct {
	client client.Client
}

func NewReferenceGrantClient(client client.Client) *referenceGrantClient {
	return &referenceGrantClient{client: client}
}

func (c *referenceGrantClient) GetReferenceGrant(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.ReferenceGrant, error) {
	obj := &gateway_networking_k8s_io_v1alpha2.ReferenceGrant{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *referenceGrantClient) ListReferenceGrant(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.ReferenceGrantList, error) {
	list := &gateway_networking_k8s_io_v1alpha2.ReferenceGrantList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *referenceGrantClient) CreateReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *referenceGrantClient) DeleteReferenceGrant(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.ReferenceGrant{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *referenceGrantClient) UpdateReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *referenceGrantClient) PatchReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *referenceGrantClient) DeleteAllOfReferenceGrant(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.ReferenceGrant{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *referenceGrantClient) UpsertReferenceGrant(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, transitionFuncs ...ReferenceGrantTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*gateway_networking_k8s_io_v1alpha2.ReferenceGrant), desired.(*gateway_networking_k8s_io_v1alpha2.ReferenceGrant)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *referenceGrantClient) UpdateReferenceGrantStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *referenceGrantClient) PatchReferenceGrantStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.ReferenceGrant, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides ReferenceGrantClients for multiple clusters.
type MulticlusterReferenceGrantClient interface {
	// Cluster returns a ReferenceGrantClient for the given cluster
	Cluster(cluster string) (ReferenceGrantClient, error)
}

type multiclusterReferenceGrantClient struct {
	client multicluster.Client
}

func NewMulticlusterReferenceGrantClient(client multicluster.Client) MulticlusterReferenceGrantClient {
	return &multiclusterReferenceGrantClient{client: client}
}

func (m *multiclusterReferenceGrantClient) Cluster(cluster string) (ReferenceGrantClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewReferenceGrantClient(client), nil
}

// Reader knows how to read and list GRPCRoutes.
type GRPCRouteReader interface {
	// Get retrieves a GRPCRoute for the given object key
	GetGRPCRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.GRPCRoute, error)

	// List retrieves list of GRPCRoutes for a given namespace and list options.
	ListGRPCRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.GRPCRouteList, error)
}

// GRPCRouteTransitionFunction instructs the GRPCRouteWriter how to transition between an existing
// GRPCRoute object and a desired on an Upsert
type GRPCRouteTransitionFunction func(existing, desired *gateway_networking_k8s_io_v1alpha2.GRPCRoute) error

// Writer knows how to create, delete, and update GRPCRoutes.
type GRPCRouteWriter interface {
	// Create saves the GRPCRoute object.
	CreateGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, opts ...client.CreateOption) error

	// Delete deletes the GRPCRoute object.
	DeleteGRPCRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given GRPCRoute object.
	UpdateGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, opts ...client.UpdateOption) error

	// Patch patches the given GRPCRoute object.
	PatchGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all GRPCRoute objects matching the given options.
	DeleteAllOfGRPCRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the GRPCRoute object.
	UpsertGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, transitionFuncs ...GRPCRouteTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a GRPCRoute object.
type GRPCRouteStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given GRPCRoute object.
	UpdateGRPCRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given GRPCRoute object's subresource.
	PatchGRPCRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on GRPCRoutes.
type GRPCRouteClient interface {
	GRPCRouteReader
	GRPCRouteWriter
	GRPCRouteStatusWriter
}

type gRPCRouteClient struct {
	client client.Client
}

func NewGRPCRouteClient(client client.Client) *gRPCRouteClient {
	return &gRPCRouteClient{client: client}
}

func (c *gRPCRouteClient) GetGRPCRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.GRPCRoute, error) {
	obj := &gateway_networking_k8s_io_v1alpha2.GRPCRoute{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *gRPCRouteClient) ListGRPCRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.GRPCRouteList, error) {
	list := &gateway_networking_k8s_io_v1alpha2.GRPCRouteList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *gRPCRouteClient) CreateGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *gRPCRouteClient) DeleteGRPCRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.GRPCRoute{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *gRPCRouteClient) UpdateGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *gRPCRouteClient) PatchGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *gRPCRouteClient) DeleteAllOfGRPCRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.GRPCRoute{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *gRPCRouteClient) UpsertGRPCRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, transitionFuncs ...GRPCRouteTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*gateway_networking_k8s_io_v1alpha2.GRPCRoute), desired.(*gateway_networking_k8s_io_v1alpha2.GRPCRoute)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *gRPCRouteClient) UpdateGRPCRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *gRPCRouteClient) PatchGRPCRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides GRPCRouteClients for multiple clusters.
type MulticlusterGRPCRouteClient interface {
	// Cluster returns a GRPCRouteClient for the given cluster
	Cluster(cluster string) (GRPCRouteClient, error)
}

type multiclusterGRPCRouteClient struct {
	client multicluster.Client
}

func NewMulticlusterGRPCRouteClient(client multicluster.Client) MulticlusterGRPCRouteClient {
	return &multiclusterGRPCRouteClient{client: client}
}

func (m *multiclusterGRPCRouteClient) Cluster(cluster string) (GRPCRouteClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewGRPCRouteClient(client), nil
}

// Reader knows how to read and list TCPRoutes.
type TCPRouteReader interface {
	// Get retrieves a TCPRoute for the given object key
	GetTCPRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.TCPRoute, error)

	// List retrieves list of TCPRoutes for a given namespace and list options.
	ListTCPRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.TCPRouteList, error)
}

// TCPRouteTransitionFunction instructs the TCPRouteWriter how to transition between an existing
// TCPRoute object and a desired on an Upsert
type TCPRouteTransitionFunction func(existing, desired *gateway_networking_k8s_io_v1alpha2.TCPRoute) error

// Writer knows how to create, delete, and update TCPRoutes.
type TCPRouteWriter interface {
	// Create saves the TCPRoute object.
	CreateTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, opts ...client.CreateOption) error

	// Delete deletes the TCPRoute object.
	DeleteTCPRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given TCPRoute object.
	UpdateTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, opts ...client.UpdateOption) error

	// Patch patches the given TCPRoute object.
	PatchTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all TCPRoute objects matching the given options.
	DeleteAllOfTCPRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the TCPRoute object.
	UpsertTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, transitionFuncs ...TCPRouteTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a TCPRoute object.
type TCPRouteStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given TCPRoute object.
	UpdateTCPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given TCPRoute object's subresource.
	PatchTCPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on TCPRoutes.
type TCPRouteClient interface {
	TCPRouteReader
	TCPRouteWriter
	TCPRouteStatusWriter
}

type tCPRouteClient struct {
	client client.Client
}

func NewTCPRouteClient(client client.Client) *tCPRouteClient {
	return &tCPRouteClient{client: client}
}

func (c *tCPRouteClient) GetTCPRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.TCPRoute, error) {
	obj := &gateway_networking_k8s_io_v1alpha2.TCPRoute{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *tCPRouteClient) ListTCPRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.TCPRouteList, error) {
	list := &gateway_networking_k8s_io_v1alpha2.TCPRouteList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *tCPRouteClient) CreateTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *tCPRouteClient) DeleteTCPRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.TCPRoute{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *tCPRouteClient) UpdateTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *tCPRouteClient) PatchTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *tCPRouteClient) DeleteAllOfTCPRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.TCPRoute{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *tCPRouteClient) UpsertTCPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, transitionFuncs ...TCPRouteTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*gateway_networking_k8s_io_v1alpha2.TCPRoute), desired.(*gateway_networking_k8s_io_v1alpha2.TCPRoute)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *tCPRouteClient) UpdateTCPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *tCPRouteClient) PatchTCPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides TCPRouteClients for multiple clusters.
type MulticlusterTCPRouteClient interface {
	// Cluster returns a TCPRouteClient for the given cluster
	Cluster(cluster string) (TCPRouteClient, error)
}

type multiclusterTCPRouteClient struct {
	client multicluster.Client
}

func NewMulticlusterTCPRouteClient(client multicluster.Client) MulticlusterTCPRouteClient {
	return &multiclusterTCPRouteClient{client: client}
}

func (m *multiclusterTCPRouteClient) Cluster(cluster string) (TCPRouteClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewTCPRouteClient(client), nil
}

// Reader knows how to read and list TLSRoutes.
type TLSRouteReader interface {
	// Get retrieves a TLSRoute for the given object key
	GetTLSRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.TLSRoute, error)

	// List retrieves list of TLSRoutes for a given namespace and list options.
	ListTLSRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.TLSRouteList, error)
}

// TLSRouteTransitionFunction instructs the TLSRouteWriter how to transition between an existing
// TLSRoute object and a desired on an Upsert
type TLSRouteTransitionFunction func(existing, desired *gateway_networking_k8s_io_v1alpha2.TLSRoute) error

// Writer knows how to create, delete, and update TLSRoutes.
type TLSRouteWriter interface {
	// Create saves the TLSRoute object.
	CreateTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, opts ...client.CreateOption) error

	// Delete deletes the TLSRoute object.
	DeleteTLSRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given TLSRoute object.
	UpdateTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, opts ...client.UpdateOption) error

	// Patch patches the given TLSRoute object.
	PatchTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all TLSRoute objects matching the given options.
	DeleteAllOfTLSRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the TLSRoute object.
	UpsertTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, transitionFuncs ...TLSRouteTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a TLSRoute object.
type TLSRouteStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given TLSRoute object.
	UpdateTLSRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given TLSRoute object's subresource.
	PatchTLSRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on TLSRoutes.
type TLSRouteClient interface {
	TLSRouteReader
	TLSRouteWriter
	TLSRouteStatusWriter
}

type tLSRouteClient struct {
	client client.Client
}

func NewTLSRouteClient(client client.Client) *tLSRouteClient {
	return &tLSRouteClient{client: client}
}

func (c *tLSRouteClient) GetTLSRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.TLSRoute, error) {
	obj := &gateway_networking_k8s_io_v1alpha2.TLSRoute{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *tLSRouteClient) ListTLSRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.TLSRouteList, error) {
	list := &gateway_networking_k8s_io_v1alpha2.TLSRouteList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *tLSRouteClient) CreateTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *tLSRouteClient) DeleteTLSRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.TLSRoute{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *tLSRouteClient) UpdateTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *tLSRouteClient) PatchTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *tLSRouteClient) DeleteAllOfTLSRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.TLSRoute{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *tLSRouteClient) UpsertTLSRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, transitionFuncs ...TLSRouteTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*gateway_networking_k8s_io_v1alpha2.TLSRoute), desired.(*gateway_networking_k8s_io_v1alpha2.TLSRoute)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *tLSRouteClient) UpdateTLSRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *tLSRouteClient) PatchTLSRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides TLSRouteClients for multiple clusters.
type MulticlusterTLSRouteClient interface {
	// Cluster returns a TLSRouteClient for the given cluster
	Cluster(cluster string) (TLSRouteClient, error)
}

type multiclusterTLSRouteClient struct {
	client multicluster.Client
}

func NewMulticlusterTLSRouteClient(client multicluster.Client) MulticlusterTLSRouteClient {
	return &multiclusterTLSRouteClient{client: client}
}

func (m *multiclusterTLSRouteClient) Cluster(cluster string) (TLSRouteClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewTLSRouteClient(client), nil
}

// Reader knows how to read and list UDPRoutes.
type UDPRouteReader interface {
	// Get retrieves a UDPRoute for the given object key
	GetUDPRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.UDPRoute, error)

	// List retrieves list of UDPRoutes for a given namespace and list options.
	ListUDPRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.UDPRouteList, error)
}

// UDPRouteTransitionFunction instructs the UDPRouteWriter how to transition between an existing
// UDPRoute object and a desired on an Upsert
type UDPRouteTransitionFunction func(existing, desired *gateway_networking_k8s_io_v1alpha2.UDPRoute) error

// Writer knows how to create, delete, and update UDPRoutes.
type UDPRouteWriter interface {
	// Create saves the UDPRoute object.
	CreateUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, opts ...client.CreateOption) error

	// Delete deletes the UDPRoute object.
	DeleteUDPRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error

	// Update updates the given UDPRoute object.
	UpdateUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, opts ...client.UpdateOption) error

	// Patch patches the given UDPRoute object.
	PatchUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, patch client.Patch, opts ...client.PatchOption) error

	// DeleteAllOf deletes all UDPRoute objects matching the given options.
	DeleteAllOfUDPRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error

	// Create or Update the UDPRoute object.
	UpsertUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, transitionFuncs ...UDPRouteTransitionFunction) error
}

// StatusWriter knows how to update status subresource of a UDPRoute object.
type UDPRouteStatusWriter interface {
	// Update updates the fields corresponding to the status subresource for the
	// given UDPRoute object.
	UpdateUDPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, opts ...client.SubResourceUpdateOption) error

	// Patch patches the given UDPRoute object's subresource.
	PatchUDPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error
}

// Client knows how to perform CRUD operations on UDPRoutes.
type UDPRouteClient interface {
	UDPRouteReader
	UDPRouteWriter
	UDPRouteStatusWriter
}

type uDPRouteClient struct {
	client client.Client
}

func NewUDPRouteClient(client client.Client) *uDPRouteClient {
	return &uDPRouteClient{client: client}
}

func (c *uDPRouteClient) GetUDPRoute(ctx context.Context, key client.ObjectKey) (*gateway_networking_k8s_io_v1alpha2.UDPRoute, error) {
	obj := &gateway_networking_k8s_io_v1alpha2.UDPRoute{}
	if err := c.client.Get(ctx, key, obj); err != nil {
		return nil, err
	}
	return obj, nil
}

func (c *uDPRouteClient) ListUDPRoute(ctx context.Context, opts ...client.ListOption) (*gateway_networking_k8s_io_v1alpha2.UDPRouteList, error) {
	list := &gateway_networking_k8s_io_v1alpha2.UDPRouteList{}
	if err := c.client.List(ctx, list, opts...); err != nil {
		return nil, err
	}
	return list, nil
}

func (c *uDPRouteClient) CreateUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, opts ...client.CreateOption) error {
	return c.client.Create(ctx, obj, opts...)
}

func (c *uDPRouteClient) DeleteUDPRoute(ctx context.Context, key client.ObjectKey, opts ...client.DeleteOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.UDPRoute{}
	obj.SetName(key.Name)
	obj.SetNamespace(key.Namespace)
	return c.client.Delete(ctx, obj, opts...)
}

func (c *uDPRouteClient) UpdateUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, opts ...client.UpdateOption) error {
	return c.client.Update(ctx, obj, opts...)
}

func (c *uDPRouteClient) PatchUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, patch client.Patch, opts ...client.PatchOption) error {
	return c.client.Patch(ctx, obj, patch, opts...)
}

func (c *uDPRouteClient) DeleteAllOfUDPRoute(ctx context.Context, opts ...client.DeleteAllOfOption) error {
	obj := &gateway_networking_k8s_io_v1alpha2.UDPRoute{}
	return c.client.DeleteAllOf(ctx, obj, opts...)
}

func (c *uDPRouteClient) UpsertUDPRoute(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, transitionFuncs ...UDPRouteTransitionFunction) error {
	genericTxFunc := func(existing, desired runtime.Object) error {
		for _, txFunc := range transitionFuncs {
			if err := txFunc(existing.(*gateway_networking_k8s_io_v1alpha2.UDPRoute), desired.(*gateway_networking_k8s_io_v1alpha2.UDPRoute)); err != nil {
				return err
			}
		}
		return nil
	}
	_, err := controllerutils.Upsert(ctx, c.client, obj, genericTxFunc)
	return err
}

func (c *uDPRouteClient) UpdateUDPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, opts ...client.SubResourceUpdateOption) error {
	return c.client.Status().Update(ctx, obj, opts...)
}

func (c *uDPRouteClient) PatchUDPRouteStatus(ctx context.Context, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute, patch client.Patch, opts ...client.SubResourcePatchOption) error {
	return c.client.Status().Patch(ctx, obj, patch, opts...)
}

// Provides UDPRouteClients for multiple clusters.
type MulticlusterUDPRouteClient interface {
	// Cluster returns a UDPRouteClient for the given cluster
	Cluster(cluster string) (UDPRouteClient, error)
}

type multiclusterUDPRouteClient struct {
	client multicluster.Client
}

func NewMulticlusterUDPRouteClient(client multicluster.Client) MulticlusterUDPRouteClient {
	return &multiclusterUDPRouteClient{client: client}
}

func (m *multiclusterUDPRouteClient) Cluster(cluster string) (UDPRouteClient, error) {
	client, err := m.client.Cluster(cluster)
	if err != nil {
		return nil, err
	}
	return NewUDPRouteClient(client), nil
}
