// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./multicluster_reconcilers.go -destination mocks/multicluster_reconcilers.go

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	gateway_networking_k8s_io_v1alpha2 "sigs.k8s.io/gateway-api/apis/v1alpha2"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the GRPCRoute Resource across clusters.
// implemented by the user
type MulticlusterGRPCRouteReconciler interface {
	ReconcileGRPCRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute) (reconcile.Result, error)
}

// Reconcile deletion events for the GRPCRoute Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterGRPCRouteDeletionReconciler interface {
	ReconcileGRPCRouteDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterGRPCRouteReconcilerFuncs struct {
	OnReconcileGRPCRoute         func(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute) (reconcile.Result, error)
	OnReconcileGRPCRouteDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterGRPCRouteReconcilerFuncs) ReconcileGRPCRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.GRPCRoute) (reconcile.Result, error) {
	if f.OnReconcileGRPCRoute == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGRPCRoute(clusterName, obj)
}

func (f *MulticlusterGRPCRouteReconcilerFuncs) ReconcileGRPCRouteDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileGRPCRouteDeletion == nil {
		return nil
	}
	return f.OnReconcileGRPCRouteDeletion(clusterName, req)
}

type MulticlusterGRPCRouteReconcileLoop interface {
	// AddMulticlusterGRPCRouteReconciler adds a MulticlusterGRPCRouteReconciler to the MulticlusterGRPCRouteReconcileLoop.
	AddMulticlusterGRPCRouteReconciler(ctx context.Context, rec MulticlusterGRPCRouteReconciler, predicates ...predicate.Predicate)
}

type multiclusterGRPCRouteReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterGRPCRouteReconcileLoop) AddMulticlusterGRPCRouteReconciler(ctx context.Context, rec MulticlusterGRPCRouteReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericGRPCRouteMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterGRPCRouteReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterGRPCRouteReconcileLoop {
	return &multiclusterGRPCRouteReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &gateway_networking_k8s_io_v1alpha2.GRPCRoute{}, options)}
}

type genericGRPCRouteMulticlusterReconciler struct {
	reconciler MulticlusterGRPCRouteReconciler
}

func (g genericGRPCRouteMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterGRPCRouteDeletionReconciler); ok {
		return deletionReconciler.ReconcileGRPCRouteDeletion(cluster, req)
	}
	return nil
}

func (g genericGRPCRouteMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gateway_networking_k8s_io_v1alpha2.GRPCRoute)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: GRPCRoute handler received event for %T", object)
	}
	return g.reconciler.ReconcileGRPCRoute(cluster, obj)
}

// Reconcile Upsert events for the TCPRoute Resource across clusters.
// implemented by the user
type MulticlusterTCPRouteReconciler interface {
	ReconcileTCPRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute) (reconcile.Result, error)
}

// Reconcile deletion events for the TCPRoute Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterTCPRouteDeletionReconciler interface {
	ReconcileTCPRouteDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterTCPRouteReconcilerFuncs struct {
	OnReconcileTCPRoute         func(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute) (reconcile.Result, error)
	OnReconcileTCPRouteDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterTCPRouteReconcilerFuncs) ReconcileTCPRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.TCPRoute) (reconcile.Result, error) {
	if f.OnReconcileTCPRoute == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileTCPRoute(clusterName, obj)
}

func (f *MulticlusterTCPRouteReconcilerFuncs) ReconcileTCPRouteDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileTCPRouteDeletion == nil {
		return nil
	}
	return f.OnReconcileTCPRouteDeletion(clusterName, req)
}

type MulticlusterTCPRouteReconcileLoop interface {
	// AddMulticlusterTCPRouteReconciler adds a MulticlusterTCPRouteReconciler to the MulticlusterTCPRouteReconcileLoop.
	AddMulticlusterTCPRouteReconciler(ctx context.Context, rec MulticlusterTCPRouteReconciler, predicates ...predicate.Predicate)
}

type multiclusterTCPRouteReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterTCPRouteReconcileLoop) AddMulticlusterTCPRouteReconciler(ctx context.Context, rec MulticlusterTCPRouteReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericTCPRouteMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterTCPRouteReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterTCPRouteReconcileLoop {
	return &multiclusterTCPRouteReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &gateway_networking_k8s_io_v1alpha2.TCPRoute{}, options)}
}

type genericTCPRouteMulticlusterReconciler struct {
	reconciler MulticlusterTCPRouteReconciler
}

func (g genericTCPRouteMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterTCPRouteDeletionReconciler); ok {
		return deletionReconciler.ReconcileTCPRouteDeletion(cluster, req)
	}
	return nil
}

func (g genericTCPRouteMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gateway_networking_k8s_io_v1alpha2.TCPRoute)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: TCPRoute handler received event for %T", object)
	}
	return g.reconciler.ReconcileTCPRoute(cluster, obj)
}

// Reconcile Upsert events for the TLSRoute Resource across clusters.
// implemented by the user
type MulticlusterTLSRouteReconciler interface {
	ReconcileTLSRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute) (reconcile.Result, error)
}

// Reconcile deletion events for the TLSRoute Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterTLSRouteDeletionReconciler interface {
	ReconcileTLSRouteDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterTLSRouteReconcilerFuncs struct {
	OnReconcileTLSRoute         func(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute) (reconcile.Result, error)
	OnReconcileTLSRouteDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterTLSRouteReconcilerFuncs) ReconcileTLSRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.TLSRoute) (reconcile.Result, error) {
	if f.OnReconcileTLSRoute == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileTLSRoute(clusterName, obj)
}

func (f *MulticlusterTLSRouteReconcilerFuncs) ReconcileTLSRouteDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileTLSRouteDeletion == nil {
		return nil
	}
	return f.OnReconcileTLSRouteDeletion(clusterName, req)
}

type MulticlusterTLSRouteReconcileLoop interface {
	// AddMulticlusterTLSRouteReconciler adds a MulticlusterTLSRouteReconciler to the MulticlusterTLSRouteReconcileLoop.
	AddMulticlusterTLSRouteReconciler(ctx context.Context, rec MulticlusterTLSRouteReconciler, predicates ...predicate.Predicate)
}

type multiclusterTLSRouteReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterTLSRouteReconcileLoop) AddMulticlusterTLSRouteReconciler(ctx context.Context, rec MulticlusterTLSRouteReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericTLSRouteMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterTLSRouteReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterTLSRouteReconcileLoop {
	return &multiclusterTLSRouteReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &gateway_networking_k8s_io_v1alpha2.TLSRoute{}, options)}
}

type genericTLSRouteMulticlusterReconciler struct {
	reconciler MulticlusterTLSRouteReconciler
}

func (g genericTLSRouteMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterTLSRouteDeletionReconciler); ok {
		return deletionReconciler.ReconcileTLSRouteDeletion(cluster, req)
	}
	return nil
}

func (g genericTLSRouteMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gateway_networking_k8s_io_v1alpha2.TLSRoute)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: TLSRoute handler received event for %T", object)
	}
	return g.reconciler.ReconcileTLSRoute(cluster, obj)
}

// Reconcile Upsert events for the UDPRoute Resource across clusters.
// implemented by the user
type MulticlusterUDPRouteReconciler interface {
	ReconcileUDPRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute) (reconcile.Result, error)
}

// Reconcile deletion events for the UDPRoute Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterUDPRouteDeletionReconciler interface {
	ReconcileUDPRouteDeletion(clusterName string, req reconcile.Request) error
}

type MulticlusterUDPRouteReconcilerFuncs struct {
	OnReconcileUDPRoute         func(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute) (reconcile.Result, error)
	OnReconcileUDPRouteDeletion func(clusterName string, req reconcile.Request) error
}

func (f *MulticlusterUDPRouteReconcilerFuncs) ReconcileUDPRoute(clusterName string, obj *gateway_networking_k8s_io_v1alpha2.UDPRoute) (reconcile.Result, error) {
	if f.OnReconcileUDPRoute == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileUDPRoute(clusterName, obj)
}

func (f *MulticlusterUDPRouteReconcilerFuncs) ReconcileUDPRouteDeletion(clusterName string, req reconcile.Request) error {
	if f.OnReconcileUDPRouteDeletion == nil {
		return nil
	}
	return f.OnReconcileUDPRouteDeletion(clusterName, req)
}

type MulticlusterUDPRouteReconcileLoop interface {
	// AddMulticlusterUDPRouteReconciler adds a MulticlusterUDPRouteReconciler to the MulticlusterUDPRouteReconcileLoop.
	AddMulticlusterUDPRouteReconciler(ctx context.Context, rec MulticlusterUDPRouteReconciler, predicates ...predicate.Predicate)
}

type multiclusterUDPRouteReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterUDPRouteReconcileLoop) AddMulticlusterUDPRouteReconciler(ctx context.Context, rec MulticlusterUDPRouteReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericUDPRouteMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterUDPRouteReconcileLoop(name string, cw multicluster.ClusterWatcher, options reconcile.Options) MulticlusterUDPRouteReconcileLoop {
	return &multiclusterUDPRouteReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &gateway_networking_k8s_io_v1alpha2.UDPRoute{}, options)}
}

type genericUDPRouteMulticlusterReconciler struct {
	reconciler MulticlusterUDPRouteReconciler
}

func (g genericUDPRouteMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) error {
	if deletionReconciler, ok := g.reconciler.(MulticlusterUDPRouteDeletionReconciler); ok {
		return deletionReconciler.ReconcileUDPRouteDeletion(cluster, req)
	}
	return nil
}

func (g genericUDPRouteMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gateway_networking_k8s_io_v1alpha2.UDPRoute)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: UDPRoute handler received event for %T", object)
	}
	return g.reconciler.ReconcileUDPRoute(cluster, obj)
}
