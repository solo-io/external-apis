// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1beta2sets

import (
	appmesh_k8s_aws_v1beta2 "github.com/aws/aws-app-mesh-controller-for-k8s/apis/appmesh/v1beta2"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type MeshSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*appmesh_k8s_aws_v1beta2.Mesh) bool) []*appmesh_k8s_aws_v1beta2.Mesh
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.Mesh) bool) []*appmesh_k8s_aws_v1beta2.Mesh
	// Return the Set as a map of key to resource.
	Map() map[string]*appmesh_k8s_aws_v1beta2.Mesh
	// Insert a resource into the set.
	Insert(mesh ...*appmesh_k8s_aws_v1beta2.Mesh)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(meshSet MeshSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(mesh ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(mesh ezkube.ResourceId)
	// Return the union with the provided set
	Union(set MeshSet) MeshSet
	// Return the difference with the provided set
	Difference(set MeshSet) MeshSet
	// Return the intersection with the provided set
	Intersection(set MeshSet) MeshSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.Mesh, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another MeshSet
	Delta(newSet MeshSet) sksets.ResourceDelta
	// Create a deep copy of the current MeshSet
	Clone() MeshSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericMeshSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	meshList []*appmesh_k8s_aws_v1beta2.Mesh,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range meshList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type meshSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewMeshSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	meshList ...*appmesh_k8s_aws_v1beta2.Mesh,
) MeshSet {
	return &meshSet{
		set:          makeGenericMeshSet(sortFunc, equalityFunc, meshList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewMeshSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	meshList *appmesh_k8s_aws_v1beta2.MeshList,
) MeshSet {
	list := make([]*appmesh_k8s_aws_v1beta2.Mesh, 0, len(meshList.Items))
	for idx := range meshList.Items {
		list = append(list, &meshList.Items[idx])
	}
	return &meshSet{
		set:          makeGenericMeshSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *meshSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *meshSet) List(filterResource ...func(*appmesh_k8s_aws_v1beta2.Mesh) bool) []*appmesh_k8s_aws_v1beta2.Mesh {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.Mesh))
		})
	}

	objs := s.Generic().List(genericFilters...)
	meshList := make([]*appmesh_k8s_aws_v1beta2.Mesh, 0, len(objs))
	for _, obj := range objs {
		meshList = append(meshList, obj.(*appmesh_k8s_aws_v1beta2.Mesh))
	}
	return meshList
}

func (s *meshSet) UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.Mesh) bool) []*appmesh_k8s_aws_v1beta2.Mesh {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.Mesh))
		})
	}

	var meshList []*appmesh_k8s_aws_v1beta2.Mesh
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		meshList = append(meshList, obj.(*appmesh_k8s_aws_v1beta2.Mesh))
	}
	return meshList
}

func (s *meshSet) Map() map[string]*appmesh_k8s_aws_v1beta2.Mesh {
	if s == nil {
		return nil
	}

	newMap := map[string]*appmesh_k8s_aws_v1beta2.Mesh{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*appmesh_k8s_aws_v1beta2.Mesh)
	}
	return newMap
}

func (s *meshSet) Insert(
	meshList ...*appmesh_k8s_aws_v1beta2.Mesh,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range meshList {
		s.Generic().Insert(obj)
	}
}

func (s *meshSet) Has(mesh ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(mesh)
}

func (s *meshSet) Equal(
	meshSet MeshSet,
) bool {
	if s == nil {
		return meshSet == nil
	}
	return s.Generic().Equal(meshSet.Generic())
}

func (s *meshSet) Delete(Mesh ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Mesh)
}

func (s *meshSet) Union(set MeshSet) MeshSet {
	if s == nil {
		return set
	}
	return NewMeshSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *meshSet) Difference(set MeshSet) MeshSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &meshSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *meshSet) Intersection(set MeshSet) MeshSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var meshList []*appmesh_k8s_aws_v1beta2.Mesh
	for _, obj := range newSet.List() {
		meshList = append(meshList, obj.(*appmesh_k8s_aws_v1beta2.Mesh))
	}
	return NewMeshSet(s.sortFunc, s.equalityFunc, meshList...)
}

func (s *meshSet) Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.Mesh, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Mesh %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&appmesh_k8s_aws_v1beta2.Mesh{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*appmesh_k8s_aws_v1beta2.Mesh), nil
}

func (s *meshSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *meshSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *meshSet) Delta(newSet MeshSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *meshSet) Clone() MeshSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &meshSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *meshSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *meshSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type VirtualServiceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualService) bool) []*appmesh_k8s_aws_v1beta2.VirtualService
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualService) bool) []*appmesh_k8s_aws_v1beta2.VirtualService
	// Return the Set as a map of key to resource.
	Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualService
	// Insert a resource into the set.
	Insert(virtualService ...*appmesh_k8s_aws_v1beta2.VirtualService)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(virtualServiceSet VirtualServiceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(virtualService ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(virtualService ezkube.ResourceId)
	// Return the union with the provided set
	Union(set VirtualServiceSet) VirtualServiceSet
	// Return the difference with the provided set
	Difference(set VirtualServiceSet) VirtualServiceSet
	// Return the intersection with the provided set
	Intersection(set VirtualServiceSet) VirtualServiceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualService, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another VirtualServiceSet
	Delta(newSet VirtualServiceSet) sksets.ResourceDelta
	// Create a deep copy of the current VirtualServiceSet
	Clone() VirtualServiceSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericVirtualServiceSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualServiceList []*appmesh_k8s_aws_v1beta2.VirtualService,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range virtualServiceList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type virtualServiceSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewVirtualServiceSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualServiceList ...*appmesh_k8s_aws_v1beta2.VirtualService,
) VirtualServiceSet {
	return &virtualServiceSet{
		set:          makeGenericVirtualServiceSet(sortFunc, equalityFunc, virtualServiceList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewVirtualServiceSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualServiceList *appmesh_k8s_aws_v1beta2.VirtualServiceList,
) VirtualServiceSet {
	list := make([]*appmesh_k8s_aws_v1beta2.VirtualService, 0, len(virtualServiceList.Items))
	for idx := range virtualServiceList.Items {
		list = append(list, &virtualServiceList.Items[idx])
	}
	return &virtualServiceSet{
		set:          makeGenericVirtualServiceSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *virtualServiceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *virtualServiceSet) List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualService) bool) []*appmesh_k8s_aws_v1beta2.VirtualService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualService))
		})
	}

	objs := s.Generic().List(genericFilters...)
	virtualServiceList := make([]*appmesh_k8s_aws_v1beta2.VirtualService, 0, len(objs))
	for _, obj := range objs {
		virtualServiceList = append(virtualServiceList, obj.(*appmesh_k8s_aws_v1beta2.VirtualService))
	}
	return virtualServiceList
}

func (s *virtualServiceSet) UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualService) bool) []*appmesh_k8s_aws_v1beta2.VirtualService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualService))
		})
	}

	var virtualServiceList []*appmesh_k8s_aws_v1beta2.VirtualService
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		virtualServiceList = append(virtualServiceList, obj.(*appmesh_k8s_aws_v1beta2.VirtualService))
	}
	return virtualServiceList
}

func (s *virtualServiceSet) Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualService {
	if s == nil {
		return nil
	}

	newMap := map[string]*appmesh_k8s_aws_v1beta2.VirtualService{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*appmesh_k8s_aws_v1beta2.VirtualService)
	}
	return newMap
}

func (s *virtualServiceSet) Insert(
	virtualServiceList ...*appmesh_k8s_aws_v1beta2.VirtualService,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range virtualServiceList {
		s.Generic().Insert(obj)
	}
}

func (s *virtualServiceSet) Has(virtualService ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(virtualService)
}

func (s *virtualServiceSet) Equal(
	virtualServiceSet VirtualServiceSet,
) bool {
	if s == nil {
		return virtualServiceSet == nil
	}
	return s.Generic().Equal(virtualServiceSet.Generic())
}

func (s *virtualServiceSet) Delete(VirtualService ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(VirtualService)
}

func (s *virtualServiceSet) Union(set VirtualServiceSet) VirtualServiceSet {
	if s == nil {
		return set
	}
	return NewVirtualServiceSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *virtualServiceSet) Difference(set VirtualServiceSet) VirtualServiceSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &virtualServiceSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *virtualServiceSet) Intersection(set VirtualServiceSet) VirtualServiceSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var virtualServiceList []*appmesh_k8s_aws_v1beta2.VirtualService
	for _, obj := range newSet.List() {
		virtualServiceList = append(virtualServiceList, obj.(*appmesh_k8s_aws_v1beta2.VirtualService))
	}
	return NewVirtualServiceSet(s.sortFunc, s.equalityFunc, virtualServiceList...)
}

func (s *virtualServiceSet) Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualService, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find VirtualService %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&appmesh_k8s_aws_v1beta2.VirtualService{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*appmesh_k8s_aws_v1beta2.VirtualService), nil
}

func (s *virtualServiceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *virtualServiceSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *virtualServiceSet) Delta(newSet VirtualServiceSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *virtualServiceSet) Clone() VirtualServiceSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &virtualServiceSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *virtualServiceSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *virtualServiceSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type VirtualNodeSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualNode) bool) []*appmesh_k8s_aws_v1beta2.VirtualNode
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualNode) bool) []*appmesh_k8s_aws_v1beta2.VirtualNode
	// Return the Set as a map of key to resource.
	Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualNode
	// Insert a resource into the set.
	Insert(virtualNode ...*appmesh_k8s_aws_v1beta2.VirtualNode)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(virtualNodeSet VirtualNodeSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(virtualNode ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(virtualNode ezkube.ResourceId)
	// Return the union with the provided set
	Union(set VirtualNodeSet) VirtualNodeSet
	// Return the difference with the provided set
	Difference(set VirtualNodeSet) VirtualNodeSet
	// Return the intersection with the provided set
	Intersection(set VirtualNodeSet) VirtualNodeSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualNode, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another VirtualNodeSet
	Delta(newSet VirtualNodeSet) sksets.ResourceDelta
	// Create a deep copy of the current VirtualNodeSet
	Clone() VirtualNodeSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericVirtualNodeSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualNodeList []*appmesh_k8s_aws_v1beta2.VirtualNode,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range virtualNodeList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type virtualNodeSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewVirtualNodeSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualNodeList ...*appmesh_k8s_aws_v1beta2.VirtualNode,
) VirtualNodeSet {
	return &virtualNodeSet{
		set:          makeGenericVirtualNodeSet(sortFunc, equalityFunc, virtualNodeList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewVirtualNodeSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualNodeList *appmesh_k8s_aws_v1beta2.VirtualNodeList,
) VirtualNodeSet {
	list := make([]*appmesh_k8s_aws_v1beta2.VirtualNode, 0, len(virtualNodeList.Items))
	for idx := range virtualNodeList.Items {
		list = append(list, &virtualNodeList.Items[idx])
	}
	return &virtualNodeSet{
		set:          makeGenericVirtualNodeSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *virtualNodeSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *virtualNodeSet) List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualNode) bool) []*appmesh_k8s_aws_v1beta2.VirtualNode {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualNode))
		})
	}

	objs := s.Generic().List(genericFilters...)
	virtualNodeList := make([]*appmesh_k8s_aws_v1beta2.VirtualNode, 0, len(objs))
	for _, obj := range objs {
		virtualNodeList = append(virtualNodeList, obj.(*appmesh_k8s_aws_v1beta2.VirtualNode))
	}
	return virtualNodeList
}

func (s *virtualNodeSet) UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualNode) bool) []*appmesh_k8s_aws_v1beta2.VirtualNode {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualNode))
		})
	}

	var virtualNodeList []*appmesh_k8s_aws_v1beta2.VirtualNode
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		virtualNodeList = append(virtualNodeList, obj.(*appmesh_k8s_aws_v1beta2.VirtualNode))
	}
	return virtualNodeList
}

func (s *virtualNodeSet) Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualNode {
	if s == nil {
		return nil
	}

	newMap := map[string]*appmesh_k8s_aws_v1beta2.VirtualNode{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*appmesh_k8s_aws_v1beta2.VirtualNode)
	}
	return newMap
}

func (s *virtualNodeSet) Insert(
	virtualNodeList ...*appmesh_k8s_aws_v1beta2.VirtualNode,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range virtualNodeList {
		s.Generic().Insert(obj)
	}
}

func (s *virtualNodeSet) Has(virtualNode ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(virtualNode)
}

func (s *virtualNodeSet) Equal(
	virtualNodeSet VirtualNodeSet,
) bool {
	if s == nil {
		return virtualNodeSet == nil
	}
	return s.Generic().Equal(virtualNodeSet.Generic())
}

func (s *virtualNodeSet) Delete(VirtualNode ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(VirtualNode)
}

func (s *virtualNodeSet) Union(set VirtualNodeSet) VirtualNodeSet {
	if s == nil {
		return set
	}
	return NewVirtualNodeSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *virtualNodeSet) Difference(set VirtualNodeSet) VirtualNodeSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &virtualNodeSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *virtualNodeSet) Intersection(set VirtualNodeSet) VirtualNodeSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var virtualNodeList []*appmesh_k8s_aws_v1beta2.VirtualNode
	for _, obj := range newSet.List() {
		virtualNodeList = append(virtualNodeList, obj.(*appmesh_k8s_aws_v1beta2.VirtualNode))
	}
	return NewVirtualNodeSet(s.sortFunc, s.equalityFunc, virtualNodeList...)
}

func (s *virtualNodeSet) Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualNode, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find VirtualNode %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&appmesh_k8s_aws_v1beta2.VirtualNode{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*appmesh_k8s_aws_v1beta2.VirtualNode), nil
}

func (s *virtualNodeSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *virtualNodeSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *virtualNodeSet) Delta(newSet VirtualNodeSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *virtualNodeSet) Clone() VirtualNodeSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &virtualNodeSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *virtualNodeSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *virtualNodeSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type VirtualRouterSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualRouter) bool) []*appmesh_k8s_aws_v1beta2.VirtualRouter
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualRouter) bool) []*appmesh_k8s_aws_v1beta2.VirtualRouter
	// Return the Set as a map of key to resource.
	Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualRouter
	// Insert a resource into the set.
	Insert(virtualRouter ...*appmesh_k8s_aws_v1beta2.VirtualRouter)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(virtualRouterSet VirtualRouterSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(virtualRouter ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(virtualRouter ezkube.ResourceId)
	// Return the union with the provided set
	Union(set VirtualRouterSet) VirtualRouterSet
	// Return the difference with the provided set
	Difference(set VirtualRouterSet) VirtualRouterSet
	// Return the intersection with the provided set
	Intersection(set VirtualRouterSet) VirtualRouterSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualRouter, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another VirtualRouterSet
	Delta(newSet VirtualRouterSet) sksets.ResourceDelta
	// Create a deep copy of the current VirtualRouterSet
	Clone() VirtualRouterSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericVirtualRouterSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualRouterList []*appmesh_k8s_aws_v1beta2.VirtualRouter,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range virtualRouterList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type virtualRouterSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewVirtualRouterSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualRouterList ...*appmesh_k8s_aws_v1beta2.VirtualRouter,
) VirtualRouterSet {
	return &virtualRouterSet{
		set:          makeGenericVirtualRouterSet(sortFunc, equalityFunc, virtualRouterList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewVirtualRouterSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualRouterList *appmesh_k8s_aws_v1beta2.VirtualRouterList,
) VirtualRouterSet {
	list := make([]*appmesh_k8s_aws_v1beta2.VirtualRouter, 0, len(virtualRouterList.Items))
	for idx := range virtualRouterList.Items {
		list = append(list, &virtualRouterList.Items[idx])
	}
	return &virtualRouterSet{
		set:          makeGenericVirtualRouterSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *virtualRouterSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *virtualRouterSet) List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualRouter) bool) []*appmesh_k8s_aws_v1beta2.VirtualRouter {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualRouter))
		})
	}

	objs := s.Generic().List(genericFilters...)
	virtualRouterList := make([]*appmesh_k8s_aws_v1beta2.VirtualRouter, 0, len(objs))
	for _, obj := range objs {
		virtualRouterList = append(virtualRouterList, obj.(*appmesh_k8s_aws_v1beta2.VirtualRouter))
	}
	return virtualRouterList
}

func (s *virtualRouterSet) UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualRouter) bool) []*appmesh_k8s_aws_v1beta2.VirtualRouter {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualRouter))
		})
	}

	var virtualRouterList []*appmesh_k8s_aws_v1beta2.VirtualRouter
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		virtualRouterList = append(virtualRouterList, obj.(*appmesh_k8s_aws_v1beta2.VirtualRouter))
	}
	return virtualRouterList
}

func (s *virtualRouterSet) Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualRouter {
	if s == nil {
		return nil
	}

	newMap := map[string]*appmesh_k8s_aws_v1beta2.VirtualRouter{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*appmesh_k8s_aws_v1beta2.VirtualRouter)
	}
	return newMap
}

func (s *virtualRouterSet) Insert(
	virtualRouterList ...*appmesh_k8s_aws_v1beta2.VirtualRouter,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range virtualRouterList {
		s.Generic().Insert(obj)
	}
}

func (s *virtualRouterSet) Has(virtualRouter ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(virtualRouter)
}

func (s *virtualRouterSet) Equal(
	virtualRouterSet VirtualRouterSet,
) bool {
	if s == nil {
		return virtualRouterSet == nil
	}
	return s.Generic().Equal(virtualRouterSet.Generic())
}

func (s *virtualRouterSet) Delete(VirtualRouter ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(VirtualRouter)
}

func (s *virtualRouterSet) Union(set VirtualRouterSet) VirtualRouterSet {
	if s == nil {
		return set
	}
	return NewVirtualRouterSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *virtualRouterSet) Difference(set VirtualRouterSet) VirtualRouterSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &virtualRouterSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *virtualRouterSet) Intersection(set VirtualRouterSet) VirtualRouterSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var virtualRouterList []*appmesh_k8s_aws_v1beta2.VirtualRouter
	for _, obj := range newSet.List() {
		virtualRouterList = append(virtualRouterList, obj.(*appmesh_k8s_aws_v1beta2.VirtualRouter))
	}
	return NewVirtualRouterSet(s.sortFunc, s.equalityFunc, virtualRouterList...)
}

func (s *virtualRouterSet) Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualRouter, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find VirtualRouter %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&appmesh_k8s_aws_v1beta2.VirtualRouter{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*appmesh_k8s_aws_v1beta2.VirtualRouter), nil
}

func (s *virtualRouterSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *virtualRouterSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *virtualRouterSet) Delta(newSet VirtualRouterSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *virtualRouterSet) Clone() VirtualRouterSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &virtualRouterSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *virtualRouterSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *virtualRouterSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type VirtualGatewaySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualGateway) bool) []*appmesh_k8s_aws_v1beta2.VirtualGateway
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualGateway) bool) []*appmesh_k8s_aws_v1beta2.VirtualGateway
	// Return the Set as a map of key to resource.
	Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualGateway
	// Insert a resource into the set.
	Insert(virtualGateway ...*appmesh_k8s_aws_v1beta2.VirtualGateway)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(virtualGatewaySet VirtualGatewaySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(virtualGateway ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(virtualGateway ezkube.ResourceId)
	// Return the union with the provided set
	Union(set VirtualGatewaySet) VirtualGatewaySet
	// Return the difference with the provided set
	Difference(set VirtualGatewaySet) VirtualGatewaySet
	// Return the intersection with the provided set
	Intersection(set VirtualGatewaySet) VirtualGatewaySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualGateway, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another VirtualGatewaySet
	Delta(newSet VirtualGatewaySet) sksets.ResourceDelta
	// Create a deep copy of the current VirtualGatewaySet
	Clone() VirtualGatewaySet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericVirtualGatewaySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualGatewayList []*appmesh_k8s_aws_v1beta2.VirtualGateway,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range virtualGatewayList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type virtualGatewaySet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewVirtualGatewaySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualGatewayList ...*appmesh_k8s_aws_v1beta2.VirtualGateway,
) VirtualGatewaySet {
	return &virtualGatewaySet{
		set:          makeGenericVirtualGatewaySet(sortFunc, equalityFunc, virtualGatewayList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewVirtualGatewaySetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualGatewayList *appmesh_k8s_aws_v1beta2.VirtualGatewayList,
) VirtualGatewaySet {
	list := make([]*appmesh_k8s_aws_v1beta2.VirtualGateway, 0, len(virtualGatewayList.Items))
	for idx := range virtualGatewayList.Items {
		list = append(list, &virtualGatewayList.Items[idx])
	}
	return &virtualGatewaySet{
		set:          makeGenericVirtualGatewaySet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *virtualGatewaySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *virtualGatewaySet) List(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualGateway) bool) []*appmesh_k8s_aws_v1beta2.VirtualGateway {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualGateway))
		})
	}

	objs := s.Generic().List(genericFilters...)
	virtualGatewayList := make([]*appmesh_k8s_aws_v1beta2.VirtualGateway, 0, len(objs))
	for _, obj := range objs {
		virtualGatewayList = append(virtualGatewayList, obj.(*appmesh_k8s_aws_v1beta2.VirtualGateway))
	}
	return virtualGatewayList
}

func (s *virtualGatewaySet) UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.VirtualGateway) bool) []*appmesh_k8s_aws_v1beta2.VirtualGateway {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.VirtualGateway))
		})
	}

	var virtualGatewayList []*appmesh_k8s_aws_v1beta2.VirtualGateway
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		virtualGatewayList = append(virtualGatewayList, obj.(*appmesh_k8s_aws_v1beta2.VirtualGateway))
	}
	return virtualGatewayList
}

func (s *virtualGatewaySet) Map() map[string]*appmesh_k8s_aws_v1beta2.VirtualGateway {
	if s == nil {
		return nil
	}

	newMap := map[string]*appmesh_k8s_aws_v1beta2.VirtualGateway{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*appmesh_k8s_aws_v1beta2.VirtualGateway)
	}
	return newMap
}

func (s *virtualGatewaySet) Insert(
	virtualGatewayList ...*appmesh_k8s_aws_v1beta2.VirtualGateway,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range virtualGatewayList {
		s.Generic().Insert(obj)
	}
}

func (s *virtualGatewaySet) Has(virtualGateway ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(virtualGateway)
}

func (s *virtualGatewaySet) Equal(
	virtualGatewaySet VirtualGatewaySet,
) bool {
	if s == nil {
		return virtualGatewaySet == nil
	}
	return s.Generic().Equal(virtualGatewaySet.Generic())
}

func (s *virtualGatewaySet) Delete(VirtualGateway ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(VirtualGateway)
}

func (s *virtualGatewaySet) Union(set VirtualGatewaySet) VirtualGatewaySet {
	if s == nil {
		return set
	}
	return NewVirtualGatewaySet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *virtualGatewaySet) Difference(set VirtualGatewaySet) VirtualGatewaySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &virtualGatewaySet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *virtualGatewaySet) Intersection(set VirtualGatewaySet) VirtualGatewaySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var virtualGatewayList []*appmesh_k8s_aws_v1beta2.VirtualGateway
	for _, obj := range newSet.List() {
		virtualGatewayList = append(virtualGatewayList, obj.(*appmesh_k8s_aws_v1beta2.VirtualGateway))
	}
	return NewVirtualGatewaySet(s.sortFunc, s.equalityFunc, virtualGatewayList...)
}

func (s *virtualGatewaySet) Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.VirtualGateway, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find VirtualGateway %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&appmesh_k8s_aws_v1beta2.VirtualGateway{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*appmesh_k8s_aws_v1beta2.VirtualGateway), nil
}

func (s *virtualGatewaySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *virtualGatewaySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *virtualGatewaySet) Delta(newSet VirtualGatewaySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *virtualGatewaySet) Clone() VirtualGatewaySet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &virtualGatewaySet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *virtualGatewaySet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *virtualGatewaySet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type GatewayRouteSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*appmesh_k8s_aws_v1beta2.GatewayRoute) bool) []*appmesh_k8s_aws_v1beta2.GatewayRoute
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.GatewayRoute) bool) []*appmesh_k8s_aws_v1beta2.GatewayRoute
	// Return the Set as a map of key to resource.
	Map() map[string]*appmesh_k8s_aws_v1beta2.GatewayRoute
	// Insert a resource into the set.
	Insert(gatewayRoute ...*appmesh_k8s_aws_v1beta2.GatewayRoute)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(gatewayRouteSet GatewayRouteSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(gatewayRoute ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(gatewayRoute ezkube.ResourceId)
	// Return the union with the provided set
	Union(set GatewayRouteSet) GatewayRouteSet
	// Return the difference with the provided set
	Difference(set GatewayRouteSet) GatewayRouteSet
	// Return the intersection with the provided set
	Intersection(set GatewayRouteSet) GatewayRouteSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.GatewayRoute, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another GatewayRouteSet
	Delta(newSet GatewayRouteSet) sksets.ResourceDelta
	// Create a deep copy of the current GatewayRouteSet
	Clone() GatewayRouteSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericGatewayRouteSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	gatewayRouteList []*appmesh_k8s_aws_v1beta2.GatewayRoute,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range gatewayRouteList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type gatewayRouteSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewGatewayRouteSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	gatewayRouteList ...*appmesh_k8s_aws_v1beta2.GatewayRoute,
) GatewayRouteSet {
	return &gatewayRouteSet{
		set:          makeGenericGatewayRouteSet(sortFunc, equalityFunc, gatewayRouteList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewGatewayRouteSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	gatewayRouteList *appmesh_k8s_aws_v1beta2.GatewayRouteList,
) GatewayRouteSet {
	list := make([]*appmesh_k8s_aws_v1beta2.GatewayRoute, 0, len(gatewayRouteList.Items))
	for idx := range gatewayRouteList.Items {
		list = append(list, &gatewayRouteList.Items[idx])
	}
	return &gatewayRouteSet{
		set:          makeGenericGatewayRouteSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *gatewayRouteSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *gatewayRouteSet) List(filterResource ...func(*appmesh_k8s_aws_v1beta2.GatewayRoute) bool) []*appmesh_k8s_aws_v1beta2.GatewayRoute {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.GatewayRoute))
		})
	}

	objs := s.Generic().List(genericFilters...)
	gatewayRouteList := make([]*appmesh_k8s_aws_v1beta2.GatewayRoute, 0, len(objs))
	for _, obj := range objs {
		gatewayRouteList = append(gatewayRouteList, obj.(*appmesh_k8s_aws_v1beta2.GatewayRoute))
	}
	return gatewayRouteList
}

func (s *gatewayRouteSet) UnsortedList(filterResource ...func(*appmesh_k8s_aws_v1beta2.GatewayRoute) bool) []*appmesh_k8s_aws_v1beta2.GatewayRoute {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*appmesh_k8s_aws_v1beta2.GatewayRoute))
		})
	}

	var gatewayRouteList []*appmesh_k8s_aws_v1beta2.GatewayRoute
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		gatewayRouteList = append(gatewayRouteList, obj.(*appmesh_k8s_aws_v1beta2.GatewayRoute))
	}
	return gatewayRouteList
}

func (s *gatewayRouteSet) Map() map[string]*appmesh_k8s_aws_v1beta2.GatewayRoute {
	if s == nil {
		return nil
	}

	newMap := map[string]*appmesh_k8s_aws_v1beta2.GatewayRoute{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*appmesh_k8s_aws_v1beta2.GatewayRoute)
	}
	return newMap
}

func (s *gatewayRouteSet) Insert(
	gatewayRouteList ...*appmesh_k8s_aws_v1beta2.GatewayRoute,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range gatewayRouteList {
		s.Generic().Insert(obj)
	}
}

func (s *gatewayRouteSet) Has(gatewayRoute ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(gatewayRoute)
}

func (s *gatewayRouteSet) Equal(
	gatewayRouteSet GatewayRouteSet,
) bool {
	if s == nil {
		return gatewayRouteSet == nil
	}
	return s.Generic().Equal(gatewayRouteSet.Generic())
}

func (s *gatewayRouteSet) Delete(GatewayRoute ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(GatewayRoute)
}

func (s *gatewayRouteSet) Union(set GatewayRouteSet) GatewayRouteSet {
	if s == nil {
		return set
	}
	return NewGatewayRouteSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *gatewayRouteSet) Difference(set GatewayRouteSet) GatewayRouteSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &gatewayRouteSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *gatewayRouteSet) Intersection(set GatewayRouteSet) GatewayRouteSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var gatewayRouteList []*appmesh_k8s_aws_v1beta2.GatewayRoute
	for _, obj := range newSet.List() {
		gatewayRouteList = append(gatewayRouteList, obj.(*appmesh_k8s_aws_v1beta2.GatewayRoute))
	}
	return NewGatewayRouteSet(s.sortFunc, s.equalityFunc, gatewayRouteList...)
}

func (s *gatewayRouteSet) Find(id ezkube.ResourceId) (*appmesh_k8s_aws_v1beta2.GatewayRoute, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find GatewayRoute %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&appmesh_k8s_aws_v1beta2.GatewayRoute{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*appmesh_k8s_aws_v1beta2.GatewayRoute), nil
}

func (s *gatewayRouteSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *gatewayRouteSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *gatewayRouteSet) Delta(newSet GatewayRouteSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *gatewayRouteSet) Clone() GatewayRouteSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &gatewayRouteSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *gatewayRouteSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *gatewayRouteSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}
