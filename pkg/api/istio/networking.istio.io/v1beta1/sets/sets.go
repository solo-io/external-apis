// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1beta1sets

import (
	networking_istio_io_v1beta1 "istio.io/client-go/pkg/apis/networking/v1beta1"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type DestinationRuleSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.DestinationRule) bool) []*networking_istio_io_v1beta1.DestinationRule
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.DestinationRule) bool) []*networking_istio_io_v1beta1.DestinationRule
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.DestinationRule
	// Insert a resource into the set.
	Insert(destinationRule ...*networking_istio_io_v1beta1.DestinationRule)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(destinationRuleSet DestinationRuleSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(destinationRule ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(destinationRule ezkube.ResourceId)
	// Return the union with the provided set
	Union(set DestinationRuleSet) DestinationRuleSet
	// Return the difference with the provided set
	Difference(set DestinationRuleSet) DestinationRuleSet
	// Return the intersection with the provided set
	Intersection(set DestinationRuleSet) DestinationRuleSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.DestinationRule, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another DestinationRuleSet
	Delta(newSet DestinationRuleSet) sksets.ResourceDelta
	// Create a deep copy of the current DestinationRuleSet
	Clone() DestinationRuleSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericDestinationRuleSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	destinationRuleList []*networking_istio_io_v1beta1.DestinationRule,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range destinationRuleList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type destinationRuleSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewDestinationRuleSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	destinationRuleList ...*networking_istio_io_v1beta1.DestinationRule,
) DestinationRuleSet {
	return &destinationRuleSet{
		set:          makeGenericDestinationRuleSet(sortFunc, equalityFunc, destinationRuleList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewDestinationRuleSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	destinationRuleList *networking_istio_io_v1beta1.DestinationRuleList,
) DestinationRuleSet {
	list := make([]*networking_istio_io_v1beta1.DestinationRule, 0, len(destinationRuleList.Items))
	for idx := range destinationRuleList.Items {
		list = append(list, destinationRuleList.Items[idx])
	}
	return &destinationRuleSet{
		set:          makeGenericDestinationRuleSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *destinationRuleSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *destinationRuleSet) List(filterResource ...func(*networking_istio_io_v1beta1.DestinationRule) bool) []*networking_istio_io_v1beta1.DestinationRule {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.DestinationRule))
		})
	}

	objs := s.Generic().List(genericFilters...)
	destinationRuleList := make([]*networking_istio_io_v1beta1.DestinationRule, 0, len(objs))
	for _, obj := range objs {
		destinationRuleList = append(destinationRuleList, obj.(*networking_istio_io_v1beta1.DestinationRule))
	}
	return destinationRuleList
}

func (s *destinationRuleSet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.DestinationRule) bool) []*networking_istio_io_v1beta1.DestinationRule {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.DestinationRule))
		})
	}

	var destinationRuleList []*networking_istio_io_v1beta1.DestinationRule
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		destinationRuleList = append(destinationRuleList, obj.(*networking_istio_io_v1beta1.DestinationRule))
	}
	return destinationRuleList
}

func (s *destinationRuleSet) Map() map[string]*networking_istio_io_v1beta1.DestinationRule {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.DestinationRule{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.DestinationRule)
	}
	return newMap
}

func (s *destinationRuleSet) Insert(
	destinationRuleList ...*networking_istio_io_v1beta1.DestinationRule,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range destinationRuleList {
		s.Generic().Insert(obj)
	}
}

func (s *destinationRuleSet) Has(destinationRule ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(destinationRule)
}

func (s *destinationRuleSet) Equal(
	destinationRuleSet DestinationRuleSet,
) bool {
	if s == nil {
		return destinationRuleSet == nil
	}
	return s.Generic().Equal(destinationRuleSet.Generic())
}

func (s *destinationRuleSet) Delete(DestinationRule ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(DestinationRule)
}

func (s *destinationRuleSet) Union(set DestinationRuleSet) DestinationRuleSet {
	if s == nil {
		return set
	}
	return NewDestinationRuleSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *destinationRuleSet) Difference(set DestinationRuleSet) DestinationRuleSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &destinationRuleSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *destinationRuleSet) Intersection(set DestinationRuleSet) DestinationRuleSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var destinationRuleList []*networking_istio_io_v1beta1.DestinationRule
	for _, obj := range newSet.List() {
		destinationRuleList = append(destinationRuleList, obj.(*networking_istio_io_v1beta1.DestinationRule))
	}
	return NewDestinationRuleSet(s.sortFunc, s.equalityFunc, destinationRuleList...)
}

func (s *destinationRuleSet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.DestinationRule, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find DestinationRule %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.DestinationRule{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.DestinationRule), nil
}

func (s *destinationRuleSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *destinationRuleSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *destinationRuleSet) Delta(newSet DestinationRuleSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *destinationRuleSet) Clone() DestinationRuleSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &destinationRuleSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *destinationRuleSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *destinationRuleSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type GatewaySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.Gateway) bool) []*networking_istio_io_v1beta1.Gateway
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.Gateway) bool) []*networking_istio_io_v1beta1.Gateway
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.Gateway
	// Insert a resource into the set.
	Insert(gateway ...*networking_istio_io_v1beta1.Gateway)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(gatewaySet GatewaySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(gateway ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(gateway ezkube.ResourceId)
	// Return the union with the provided set
	Union(set GatewaySet) GatewaySet
	// Return the difference with the provided set
	Difference(set GatewaySet) GatewaySet
	// Return the intersection with the provided set
	Intersection(set GatewaySet) GatewaySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.Gateway, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another GatewaySet
	Delta(newSet GatewaySet) sksets.ResourceDelta
	// Create a deep copy of the current GatewaySet
	Clone() GatewaySet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericGatewaySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	gatewayList []*networking_istio_io_v1beta1.Gateway,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range gatewayList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type gatewaySet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewGatewaySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	gatewayList ...*networking_istio_io_v1beta1.Gateway,
) GatewaySet {
	return &gatewaySet{
		set:          makeGenericGatewaySet(sortFunc, equalityFunc, gatewayList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewGatewaySetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	gatewayList *networking_istio_io_v1beta1.GatewayList,
) GatewaySet {
	list := make([]*networking_istio_io_v1beta1.Gateway, 0, len(gatewayList.Items))
	for idx := range gatewayList.Items {
		list = append(list, gatewayList.Items[idx])
	}
	return &gatewaySet{
		set:          makeGenericGatewaySet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *gatewaySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *gatewaySet) List(filterResource ...func(*networking_istio_io_v1beta1.Gateway) bool) []*networking_istio_io_v1beta1.Gateway {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.Gateway))
		})
	}

	objs := s.Generic().List(genericFilters...)
	gatewayList := make([]*networking_istio_io_v1beta1.Gateway, 0, len(objs))
	for _, obj := range objs {
		gatewayList = append(gatewayList, obj.(*networking_istio_io_v1beta1.Gateway))
	}
	return gatewayList
}

func (s *gatewaySet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.Gateway) bool) []*networking_istio_io_v1beta1.Gateway {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.Gateway))
		})
	}

	var gatewayList []*networking_istio_io_v1beta1.Gateway
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		gatewayList = append(gatewayList, obj.(*networking_istio_io_v1beta1.Gateway))
	}
	return gatewayList
}

func (s *gatewaySet) Map() map[string]*networking_istio_io_v1beta1.Gateway {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.Gateway{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.Gateway)
	}
	return newMap
}

func (s *gatewaySet) Insert(
	gatewayList ...*networking_istio_io_v1beta1.Gateway,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range gatewayList {
		s.Generic().Insert(obj)
	}
}

func (s *gatewaySet) Has(gateway ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(gateway)
}

func (s *gatewaySet) Equal(
	gatewaySet GatewaySet,
) bool {
	if s == nil {
		return gatewaySet == nil
	}
	return s.Generic().Equal(gatewaySet.Generic())
}

func (s *gatewaySet) Delete(Gateway ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Gateway)
}

func (s *gatewaySet) Union(set GatewaySet) GatewaySet {
	if s == nil {
		return set
	}
	return NewGatewaySet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *gatewaySet) Difference(set GatewaySet) GatewaySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &gatewaySet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *gatewaySet) Intersection(set GatewaySet) GatewaySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var gatewayList []*networking_istio_io_v1beta1.Gateway
	for _, obj := range newSet.List() {
		gatewayList = append(gatewayList, obj.(*networking_istio_io_v1beta1.Gateway))
	}
	return NewGatewaySet(s.sortFunc, s.equalityFunc, gatewayList...)
}

func (s *gatewaySet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.Gateway, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Gateway %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.Gateway{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.Gateway), nil
}

func (s *gatewaySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *gatewaySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *gatewaySet) Delta(newSet GatewaySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *gatewaySet) Clone() GatewaySet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &gatewaySet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *gatewaySet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *gatewaySet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type ProxyConfigSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.ProxyConfig) bool) []*networking_istio_io_v1beta1.ProxyConfig
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.ProxyConfig) bool) []*networking_istio_io_v1beta1.ProxyConfig
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.ProxyConfig
	// Insert a resource into the set.
	Insert(proxyConfig ...*networking_istio_io_v1beta1.ProxyConfig)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(proxyConfigSet ProxyConfigSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(proxyConfig ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(proxyConfig ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ProxyConfigSet) ProxyConfigSet
	// Return the difference with the provided set
	Difference(set ProxyConfigSet) ProxyConfigSet
	// Return the intersection with the provided set
	Intersection(set ProxyConfigSet) ProxyConfigSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.ProxyConfig, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ProxyConfigSet
	Delta(newSet ProxyConfigSet) sksets.ResourceDelta
	// Create a deep copy of the current ProxyConfigSet
	Clone() ProxyConfigSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericProxyConfigSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	proxyConfigList []*networking_istio_io_v1beta1.ProxyConfig,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range proxyConfigList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type proxyConfigSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewProxyConfigSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	proxyConfigList ...*networking_istio_io_v1beta1.ProxyConfig,
) ProxyConfigSet {
	return &proxyConfigSet{
		set:          makeGenericProxyConfigSet(sortFunc, equalityFunc, proxyConfigList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewProxyConfigSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	proxyConfigList *networking_istio_io_v1beta1.ProxyConfigList,
) ProxyConfigSet {
	list := make([]*networking_istio_io_v1beta1.ProxyConfig, 0, len(proxyConfigList.Items))
	for idx := range proxyConfigList.Items {
		list = append(list, proxyConfigList.Items[idx])
	}
	return &proxyConfigSet{
		set:          makeGenericProxyConfigSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *proxyConfigSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *proxyConfigSet) List(filterResource ...func(*networking_istio_io_v1beta1.ProxyConfig) bool) []*networking_istio_io_v1beta1.ProxyConfig {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.ProxyConfig))
		})
	}

	objs := s.Generic().List(genericFilters...)
	proxyConfigList := make([]*networking_istio_io_v1beta1.ProxyConfig, 0, len(objs))
	for _, obj := range objs {
		proxyConfigList = append(proxyConfigList, obj.(*networking_istio_io_v1beta1.ProxyConfig))
	}
	return proxyConfigList
}

func (s *proxyConfigSet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.ProxyConfig) bool) []*networking_istio_io_v1beta1.ProxyConfig {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.ProxyConfig))
		})
	}

	var proxyConfigList []*networking_istio_io_v1beta1.ProxyConfig
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		proxyConfigList = append(proxyConfigList, obj.(*networking_istio_io_v1beta1.ProxyConfig))
	}
	return proxyConfigList
}

func (s *proxyConfigSet) Map() map[string]*networking_istio_io_v1beta1.ProxyConfig {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.ProxyConfig{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.ProxyConfig)
	}
	return newMap
}

func (s *proxyConfigSet) Insert(
	proxyConfigList ...*networking_istio_io_v1beta1.ProxyConfig,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range proxyConfigList {
		s.Generic().Insert(obj)
	}
}

func (s *proxyConfigSet) Has(proxyConfig ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(proxyConfig)
}

func (s *proxyConfigSet) Equal(
	proxyConfigSet ProxyConfigSet,
) bool {
	if s == nil {
		return proxyConfigSet == nil
	}
	return s.Generic().Equal(proxyConfigSet.Generic())
}

func (s *proxyConfigSet) Delete(ProxyConfig ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ProxyConfig)
}

func (s *proxyConfigSet) Union(set ProxyConfigSet) ProxyConfigSet {
	if s == nil {
		return set
	}
	return NewProxyConfigSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *proxyConfigSet) Difference(set ProxyConfigSet) ProxyConfigSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &proxyConfigSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *proxyConfigSet) Intersection(set ProxyConfigSet) ProxyConfigSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var proxyConfigList []*networking_istio_io_v1beta1.ProxyConfig
	for _, obj := range newSet.List() {
		proxyConfigList = append(proxyConfigList, obj.(*networking_istio_io_v1beta1.ProxyConfig))
	}
	return NewProxyConfigSet(s.sortFunc, s.equalityFunc, proxyConfigList...)
}

func (s *proxyConfigSet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.ProxyConfig, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ProxyConfig %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.ProxyConfig{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.ProxyConfig), nil
}

func (s *proxyConfigSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *proxyConfigSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *proxyConfigSet) Delta(newSet ProxyConfigSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *proxyConfigSet) Clone() ProxyConfigSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &proxyConfigSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *proxyConfigSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *proxyConfigSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type ServiceEntrySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.ServiceEntry) bool) []*networking_istio_io_v1beta1.ServiceEntry
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.ServiceEntry) bool) []*networking_istio_io_v1beta1.ServiceEntry
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.ServiceEntry
	// Insert a resource into the set.
	Insert(serviceEntry ...*networking_istio_io_v1beta1.ServiceEntry)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(serviceEntrySet ServiceEntrySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(serviceEntry ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(serviceEntry ezkube.ResourceId)
	// Return the union with the provided set
	Union(set ServiceEntrySet) ServiceEntrySet
	// Return the difference with the provided set
	Difference(set ServiceEntrySet) ServiceEntrySet
	// Return the intersection with the provided set
	Intersection(set ServiceEntrySet) ServiceEntrySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.ServiceEntry, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another ServiceEntrySet
	Delta(newSet ServiceEntrySet) sksets.ResourceDelta
	// Create a deep copy of the current ServiceEntrySet
	Clone() ServiceEntrySet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericServiceEntrySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	serviceEntryList []*networking_istio_io_v1beta1.ServiceEntry,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range serviceEntryList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type serviceEntrySet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewServiceEntrySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	serviceEntryList ...*networking_istio_io_v1beta1.ServiceEntry,
) ServiceEntrySet {
	return &serviceEntrySet{
		set:          makeGenericServiceEntrySet(sortFunc, equalityFunc, serviceEntryList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewServiceEntrySetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	serviceEntryList *networking_istio_io_v1beta1.ServiceEntryList,
) ServiceEntrySet {
	list := make([]*networking_istio_io_v1beta1.ServiceEntry, 0, len(serviceEntryList.Items))
	for idx := range serviceEntryList.Items {
		list = append(list, serviceEntryList.Items[idx])
	}
	return &serviceEntrySet{
		set:          makeGenericServiceEntrySet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *serviceEntrySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *serviceEntrySet) List(filterResource ...func(*networking_istio_io_v1beta1.ServiceEntry) bool) []*networking_istio_io_v1beta1.ServiceEntry {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.ServiceEntry))
		})
	}

	objs := s.Generic().List(genericFilters...)
	serviceEntryList := make([]*networking_istio_io_v1beta1.ServiceEntry, 0, len(objs))
	for _, obj := range objs {
		serviceEntryList = append(serviceEntryList, obj.(*networking_istio_io_v1beta1.ServiceEntry))
	}
	return serviceEntryList
}

func (s *serviceEntrySet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.ServiceEntry) bool) []*networking_istio_io_v1beta1.ServiceEntry {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.ServiceEntry))
		})
	}

	var serviceEntryList []*networking_istio_io_v1beta1.ServiceEntry
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		serviceEntryList = append(serviceEntryList, obj.(*networking_istio_io_v1beta1.ServiceEntry))
	}
	return serviceEntryList
}

func (s *serviceEntrySet) Map() map[string]*networking_istio_io_v1beta1.ServiceEntry {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.ServiceEntry{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.ServiceEntry)
	}
	return newMap
}

func (s *serviceEntrySet) Insert(
	serviceEntryList ...*networking_istio_io_v1beta1.ServiceEntry,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range serviceEntryList {
		s.Generic().Insert(obj)
	}
}

func (s *serviceEntrySet) Has(serviceEntry ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(serviceEntry)
}

func (s *serviceEntrySet) Equal(
	serviceEntrySet ServiceEntrySet,
) bool {
	if s == nil {
		return serviceEntrySet == nil
	}
	return s.Generic().Equal(serviceEntrySet.Generic())
}

func (s *serviceEntrySet) Delete(ServiceEntry ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(ServiceEntry)
}

func (s *serviceEntrySet) Union(set ServiceEntrySet) ServiceEntrySet {
	if s == nil {
		return set
	}
	return NewServiceEntrySet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *serviceEntrySet) Difference(set ServiceEntrySet) ServiceEntrySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &serviceEntrySet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *serviceEntrySet) Intersection(set ServiceEntrySet) ServiceEntrySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var serviceEntryList []*networking_istio_io_v1beta1.ServiceEntry
	for _, obj := range newSet.List() {
		serviceEntryList = append(serviceEntryList, obj.(*networking_istio_io_v1beta1.ServiceEntry))
	}
	return NewServiceEntrySet(s.sortFunc, s.equalityFunc, serviceEntryList...)
}

func (s *serviceEntrySet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.ServiceEntry, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find ServiceEntry %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.ServiceEntry{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.ServiceEntry), nil
}

func (s *serviceEntrySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *serviceEntrySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *serviceEntrySet) Delta(newSet ServiceEntrySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *serviceEntrySet) Clone() ServiceEntrySet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &serviceEntrySet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *serviceEntrySet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *serviceEntrySet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type WorkloadEntrySet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.WorkloadEntry) bool) []*networking_istio_io_v1beta1.WorkloadEntry
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.WorkloadEntry) bool) []*networking_istio_io_v1beta1.WorkloadEntry
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.WorkloadEntry
	// Insert a resource into the set.
	Insert(workloadEntry ...*networking_istio_io_v1beta1.WorkloadEntry)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(workloadEntrySet WorkloadEntrySet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(workloadEntry ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(workloadEntry ezkube.ResourceId)
	// Return the union with the provided set
	Union(set WorkloadEntrySet) WorkloadEntrySet
	// Return the difference with the provided set
	Difference(set WorkloadEntrySet) WorkloadEntrySet
	// Return the intersection with the provided set
	Intersection(set WorkloadEntrySet) WorkloadEntrySet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.WorkloadEntry, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another WorkloadEntrySet
	Delta(newSet WorkloadEntrySet) sksets.ResourceDelta
	// Create a deep copy of the current WorkloadEntrySet
	Clone() WorkloadEntrySet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericWorkloadEntrySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	workloadEntryList []*networking_istio_io_v1beta1.WorkloadEntry,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range workloadEntryList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type workloadEntrySet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewWorkloadEntrySet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	workloadEntryList ...*networking_istio_io_v1beta1.WorkloadEntry,
) WorkloadEntrySet {
	return &workloadEntrySet{
		set:          makeGenericWorkloadEntrySet(sortFunc, equalityFunc, workloadEntryList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewWorkloadEntrySetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	workloadEntryList *networking_istio_io_v1beta1.WorkloadEntryList,
) WorkloadEntrySet {
	list := make([]*networking_istio_io_v1beta1.WorkloadEntry, 0, len(workloadEntryList.Items))
	for idx := range workloadEntryList.Items {
		list = append(list, workloadEntryList.Items[idx])
	}
	return &workloadEntrySet{
		set:          makeGenericWorkloadEntrySet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *workloadEntrySet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *workloadEntrySet) List(filterResource ...func(*networking_istio_io_v1beta1.WorkloadEntry) bool) []*networking_istio_io_v1beta1.WorkloadEntry {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.WorkloadEntry))
		})
	}

	objs := s.Generic().List(genericFilters...)
	workloadEntryList := make([]*networking_istio_io_v1beta1.WorkloadEntry, 0, len(objs))
	for _, obj := range objs {
		workloadEntryList = append(workloadEntryList, obj.(*networking_istio_io_v1beta1.WorkloadEntry))
	}
	return workloadEntryList
}

func (s *workloadEntrySet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.WorkloadEntry) bool) []*networking_istio_io_v1beta1.WorkloadEntry {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.WorkloadEntry))
		})
	}

	var workloadEntryList []*networking_istio_io_v1beta1.WorkloadEntry
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		workloadEntryList = append(workloadEntryList, obj.(*networking_istio_io_v1beta1.WorkloadEntry))
	}
	return workloadEntryList
}

func (s *workloadEntrySet) Map() map[string]*networking_istio_io_v1beta1.WorkloadEntry {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.WorkloadEntry{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.WorkloadEntry)
	}
	return newMap
}

func (s *workloadEntrySet) Insert(
	workloadEntryList ...*networking_istio_io_v1beta1.WorkloadEntry,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range workloadEntryList {
		s.Generic().Insert(obj)
	}
}

func (s *workloadEntrySet) Has(workloadEntry ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(workloadEntry)
}

func (s *workloadEntrySet) Equal(
	workloadEntrySet WorkloadEntrySet,
) bool {
	if s == nil {
		return workloadEntrySet == nil
	}
	return s.Generic().Equal(workloadEntrySet.Generic())
}

func (s *workloadEntrySet) Delete(WorkloadEntry ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(WorkloadEntry)
}

func (s *workloadEntrySet) Union(set WorkloadEntrySet) WorkloadEntrySet {
	if s == nil {
		return set
	}
	return NewWorkloadEntrySet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *workloadEntrySet) Difference(set WorkloadEntrySet) WorkloadEntrySet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &workloadEntrySet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *workloadEntrySet) Intersection(set WorkloadEntrySet) WorkloadEntrySet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var workloadEntryList []*networking_istio_io_v1beta1.WorkloadEntry
	for _, obj := range newSet.List() {
		workloadEntryList = append(workloadEntryList, obj.(*networking_istio_io_v1beta1.WorkloadEntry))
	}
	return NewWorkloadEntrySet(s.sortFunc, s.equalityFunc, workloadEntryList...)
}

func (s *workloadEntrySet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.WorkloadEntry, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find WorkloadEntry %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.WorkloadEntry{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.WorkloadEntry), nil
}

func (s *workloadEntrySet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *workloadEntrySet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *workloadEntrySet) Delta(newSet WorkloadEntrySet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *workloadEntrySet) Clone() WorkloadEntrySet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &workloadEntrySet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *workloadEntrySet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *workloadEntrySet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type WorkloadGroupSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.WorkloadGroup) bool) []*networking_istio_io_v1beta1.WorkloadGroup
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.WorkloadGroup) bool) []*networking_istio_io_v1beta1.WorkloadGroup
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.WorkloadGroup
	// Insert a resource into the set.
	Insert(workloadGroup ...*networking_istio_io_v1beta1.WorkloadGroup)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(workloadGroupSet WorkloadGroupSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(workloadGroup ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(workloadGroup ezkube.ResourceId)
	// Return the union with the provided set
	Union(set WorkloadGroupSet) WorkloadGroupSet
	// Return the difference with the provided set
	Difference(set WorkloadGroupSet) WorkloadGroupSet
	// Return the intersection with the provided set
	Intersection(set WorkloadGroupSet) WorkloadGroupSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.WorkloadGroup, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another WorkloadGroupSet
	Delta(newSet WorkloadGroupSet) sksets.ResourceDelta
	// Create a deep copy of the current WorkloadGroupSet
	Clone() WorkloadGroupSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericWorkloadGroupSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	workloadGroupList []*networking_istio_io_v1beta1.WorkloadGroup,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range workloadGroupList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type workloadGroupSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewWorkloadGroupSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	workloadGroupList ...*networking_istio_io_v1beta1.WorkloadGroup,
) WorkloadGroupSet {
	return &workloadGroupSet{
		set:          makeGenericWorkloadGroupSet(sortFunc, equalityFunc, workloadGroupList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewWorkloadGroupSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	workloadGroupList *networking_istio_io_v1beta1.WorkloadGroupList,
) WorkloadGroupSet {
	list := make([]*networking_istio_io_v1beta1.WorkloadGroup, 0, len(workloadGroupList.Items))
	for idx := range workloadGroupList.Items {
		list = append(list, workloadGroupList.Items[idx])
	}
	return &workloadGroupSet{
		set:          makeGenericWorkloadGroupSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *workloadGroupSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *workloadGroupSet) List(filterResource ...func(*networking_istio_io_v1beta1.WorkloadGroup) bool) []*networking_istio_io_v1beta1.WorkloadGroup {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.WorkloadGroup))
		})
	}

	objs := s.Generic().List(genericFilters...)
	workloadGroupList := make([]*networking_istio_io_v1beta1.WorkloadGroup, 0, len(objs))
	for _, obj := range objs {
		workloadGroupList = append(workloadGroupList, obj.(*networking_istio_io_v1beta1.WorkloadGroup))
	}
	return workloadGroupList
}

func (s *workloadGroupSet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.WorkloadGroup) bool) []*networking_istio_io_v1beta1.WorkloadGroup {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.WorkloadGroup))
		})
	}

	var workloadGroupList []*networking_istio_io_v1beta1.WorkloadGroup
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		workloadGroupList = append(workloadGroupList, obj.(*networking_istio_io_v1beta1.WorkloadGroup))
	}
	return workloadGroupList
}

func (s *workloadGroupSet) Map() map[string]*networking_istio_io_v1beta1.WorkloadGroup {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.WorkloadGroup{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.WorkloadGroup)
	}
	return newMap
}

func (s *workloadGroupSet) Insert(
	workloadGroupList ...*networking_istio_io_v1beta1.WorkloadGroup,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range workloadGroupList {
		s.Generic().Insert(obj)
	}
}

func (s *workloadGroupSet) Has(workloadGroup ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(workloadGroup)
}

func (s *workloadGroupSet) Equal(
	workloadGroupSet WorkloadGroupSet,
) bool {
	if s == nil {
		return workloadGroupSet == nil
	}
	return s.Generic().Equal(workloadGroupSet.Generic())
}

func (s *workloadGroupSet) Delete(WorkloadGroup ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(WorkloadGroup)
}

func (s *workloadGroupSet) Union(set WorkloadGroupSet) WorkloadGroupSet {
	if s == nil {
		return set
	}
	return NewWorkloadGroupSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *workloadGroupSet) Difference(set WorkloadGroupSet) WorkloadGroupSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &workloadGroupSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *workloadGroupSet) Intersection(set WorkloadGroupSet) WorkloadGroupSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var workloadGroupList []*networking_istio_io_v1beta1.WorkloadGroup
	for _, obj := range newSet.List() {
		workloadGroupList = append(workloadGroupList, obj.(*networking_istio_io_v1beta1.WorkloadGroup))
	}
	return NewWorkloadGroupSet(s.sortFunc, s.equalityFunc, workloadGroupList...)
}

func (s *workloadGroupSet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.WorkloadGroup, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find WorkloadGroup %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.WorkloadGroup{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.WorkloadGroup), nil
}

func (s *workloadGroupSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *workloadGroupSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *workloadGroupSet) Delta(newSet WorkloadGroupSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *workloadGroupSet) Clone() WorkloadGroupSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &workloadGroupSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *workloadGroupSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *workloadGroupSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type VirtualServiceSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.VirtualService) bool) []*networking_istio_io_v1beta1.VirtualService
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.VirtualService) bool) []*networking_istio_io_v1beta1.VirtualService
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.VirtualService
	// Insert a resource into the set.
	Insert(virtualService ...*networking_istio_io_v1beta1.VirtualService)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(virtualServiceSet VirtualServiceSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(virtualService ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(virtualService ezkube.ResourceId)
	// Return the union with the provided set
	Union(set VirtualServiceSet) VirtualServiceSet
	// Return the difference with the provided set
	Difference(set VirtualServiceSet) VirtualServiceSet
	// Return the intersection with the provided set
	Intersection(set VirtualServiceSet) VirtualServiceSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.VirtualService, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another VirtualServiceSet
	Delta(newSet VirtualServiceSet) sksets.ResourceDelta
	// Create a deep copy of the current VirtualServiceSet
	Clone() VirtualServiceSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericVirtualServiceSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualServiceList []*networking_istio_io_v1beta1.VirtualService,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range virtualServiceList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type virtualServiceSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewVirtualServiceSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualServiceList ...*networking_istio_io_v1beta1.VirtualService,
) VirtualServiceSet {
	return &virtualServiceSet{
		set:          makeGenericVirtualServiceSet(sortFunc, equalityFunc, virtualServiceList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewVirtualServiceSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	virtualServiceList *networking_istio_io_v1beta1.VirtualServiceList,
) VirtualServiceSet {
	list := make([]*networking_istio_io_v1beta1.VirtualService, 0, len(virtualServiceList.Items))
	for idx := range virtualServiceList.Items {
		list = append(list, virtualServiceList.Items[idx])
	}
	return &virtualServiceSet{
		set:          makeGenericVirtualServiceSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *virtualServiceSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *virtualServiceSet) List(filterResource ...func(*networking_istio_io_v1beta1.VirtualService) bool) []*networking_istio_io_v1beta1.VirtualService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.VirtualService))
		})
	}

	objs := s.Generic().List(genericFilters...)
	virtualServiceList := make([]*networking_istio_io_v1beta1.VirtualService, 0, len(objs))
	for _, obj := range objs {
		virtualServiceList = append(virtualServiceList, obj.(*networking_istio_io_v1beta1.VirtualService))
	}
	return virtualServiceList
}

func (s *virtualServiceSet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.VirtualService) bool) []*networking_istio_io_v1beta1.VirtualService {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.VirtualService))
		})
	}

	var virtualServiceList []*networking_istio_io_v1beta1.VirtualService
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		virtualServiceList = append(virtualServiceList, obj.(*networking_istio_io_v1beta1.VirtualService))
	}
	return virtualServiceList
}

func (s *virtualServiceSet) Map() map[string]*networking_istio_io_v1beta1.VirtualService {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.VirtualService{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.VirtualService)
	}
	return newMap
}

func (s *virtualServiceSet) Insert(
	virtualServiceList ...*networking_istio_io_v1beta1.VirtualService,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range virtualServiceList {
		s.Generic().Insert(obj)
	}
}

func (s *virtualServiceSet) Has(virtualService ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(virtualService)
}

func (s *virtualServiceSet) Equal(
	virtualServiceSet VirtualServiceSet,
) bool {
	if s == nil {
		return virtualServiceSet == nil
	}
	return s.Generic().Equal(virtualServiceSet.Generic())
}

func (s *virtualServiceSet) Delete(VirtualService ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(VirtualService)
}

func (s *virtualServiceSet) Union(set VirtualServiceSet) VirtualServiceSet {
	if s == nil {
		return set
	}
	return NewVirtualServiceSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *virtualServiceSet) Difference(set VirtualServiceSet) VirtualServiceSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &virtualServiceSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *virtualServiceSet) Intersection(set VirtualServiceSet) VirtualServiceSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var virtualServiceList []*networking_istio_io_v1beta1.VirtualService
	for _, obj := range newSet.List() {
		virtualServiceList = append(virtualServiceList, obj.(*networking_istio_io_v1beta1.VirtualService))
	}
	return NewVirtualServiceSet(s.sortFunc, s.equalityFunc, virtualServiceList...)
}

func (s *virtualServiceSet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.VirtualService, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find VirtualService %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.VirtualService{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.VirtualService), nil
}

func (s *virtualServiceSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *virtualServiceSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *virtualServiceSet) Delta(newSet VirtualServiceSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *virtualServiceSet) Clone() VirtualServiceSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &virtualServiceSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *virtualServiceSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *virtualServiceSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}

type SidecarSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	List(filterResource ...func(*networking_istio_io_v1beta1.Sidecar) bool) []*networking_istio_io_v1beta1.Sidecar
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	// The filter function should return false to keep the resource, true to drop it.
	UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.Sidecar) bool) []*networking_istio_io_v1beta1.Sidecar
	// Return the Set as a map of key to resource.
	Map() map[string]*networking_istio_io_v1beta1.Sidecar
	// Insert a resource into the set.
	Insert(sidecar ...*networking_istio_io_v1beta1.Sidecar)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(sidecarSet SidecarSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(sidecar ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(sidecar ezkube.ResourceId)
	// Return the union with the provided set
	Union(set SidecarSet) SidecarSet
	// Return the difference with the provided set
	Difference(set SidecarSet) SidecarSet
	// Return the intersection with the provided set
	Intersection(set SidecarSet) SidecarSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.Sidecar, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another SidecarSet
	Delta(newSet SidecarSet) sksets.ResourceDelta
	// Create a deep copy of the current SidecarSet
	Clone() SidecarSet
	// Get the sort function used by the set
	GetSortFunc() func(toInsert, existing client.Object) bool
	// Get the equality function used by the set
	GetEqualityFunc() func(a, b client.Object) bool
}

func makeGenericSidecarSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	sidecarList []*networking_istio_io_v1beta1.Sidecar,
) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range sidecarList {
		genericResources = append(genericResources, obj)
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return equalityFunc(a.(client.Object), b.(client.Object))
	}
	return sksets.NewResourceSet(genericSortFunc, genericEqualityFunc, genericResources...)
}

type sidecarSet struct {
	set          sksets.ResourceSet
	sortFunc     func(toInsert, existing client.Object) bool
	equalityFunc func(a, b client.Object) bool
}

func NewSidecarSet(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	sidecarList ...*networking_istio_io_v1beta1.Sidecar,
) SidecarSet {
	return &sidecarSet{
		set:          makeGenericSidecarSet(sortFunc, equalityFunc, sidecarList),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func NewSidecarSetFromList(
	sortFunc func(toInsert, existing client.Object) bool,
	equalityFunc func(a, b client.Object) bool,
	sidecarList *networking_istio_io_v1beta1.SidecarList,
) SidecarSet {
	list := make([]*networking_istio_io_v1beta1.Sidecar, 0, len(sidecarList.Items))
	for idx := range sidecarList.Items {
		list = append(list, sidecarList.Items[idx])
	}
	return &sidecarSet{
		set:          makeGenericSidecarSet(sortFunc, equalityFunc, list),
		sortFunc:     sortFunc,
		equalityFunc: equalityFunc,
	}
}

func (s *sidecarSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *sidecarSet) List(filterResource ...func(*networking_istio_io_v1beta1.Sidecar) bool) []*networking_istio_io_v1beta1.Sidecar {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.Sidecar))
		})
	}

	objs := s.Generic().List(genericFilters...)
	sidecarList := make([]*networking_istio_io_v1beta1.Sidecar, 0, len(objs))
	for _, obj := range objs {
		sidecarList = append(sidecarList, obj.(*networking_istio_io_v1beta1.Sidecar))
	}
	return sidecarList
}

func (s *sidecarSet) UnsortedList(filterResource ...func(*networking_istio_io_v1beta1.Sidecar) bool) []*networking_istio_io_v1beta1.Sidecar {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*networking_istio_io_v1beta1.Sidecar))
		})
	}

	var sidecarList []*networking_istio_io_v1beta1.Sidecar
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		sidecarList = append(sidecarList, obj.(*networking_istio_io_v1beta1.Sidecar))
	}
	return sidecarList
}

func (s *sidecarSet) Map() map[string]*networking_istio_io_v1beta1.Sidecar {
	if s == nil {
		return nil
	}

	newMap := map[string]*networking_istio_io_v1beta1.Sidecar{}
	for k, v := range s.Generic().Map().Map() {
		newMap[k] = v.(*networking_istio_io_v1beta1.Sidecar)
	}
	return newMap
}

func (s *sidecarSet) Insert(
	sidecarList ...*networking_istio_io_v1beta1.Sidecar,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range sidecarList {
		s.Generic().Insert(obj)
	}
}

func (s *sidecarSet) Has(sidecar ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(sidecar)
}

func (s *sidecarSet) Equal(
	sidecarSet SidecarSet,
) bool {
	if s == nil {
		return sidecarSet == nil
	}
	return s.Generic().Equal(sidecarSet.Generic())
}

func (s *sidecarSet) Delete(Sidecar ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Sidecar)
}

func (s *sidecarSet) Union(set SidecarSet) SidecarSet {
	if s == nil {
		return set
	}
	return NewSidecarSet(s.sortFunc, s.equalityFunc, append(s.List(), set.List()...)...)
}

func (s *sidecarSet) Difference(set SidecarSet) SidecarSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &sidecarSet{
		set:          newSet,
		sortFunc:     s.sortFunc,
		equalityFunc: s.equalityFunc,
	}
}

func (s *sidecarSet) Intersection(set SidecarSet) SidecarSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var sidecarList []*networking_istio_io_v1beta1.Sidecar
	for _, obj := range newSet.List() {
		sidecarList = append(sidecarList, obj.(*networking_istio_io_v1beta1.Sidecar))
	}
	return NewSidecarSet(s.sortFunc, s.equalityFunc, sidecarList...)
}

func (s *sidecarSet) Find(id ezkube.ResourceId) (*networking_istio_io_v1beta1.Sidecar, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Sidecar %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&networking_istio_io_v1beta1.Sidecar{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*networking_istio_io_v1beta1.Sidecar), nil
}

func (s *sidecarSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *sidecarSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *sidecarSet) Delta(newSet SidecarSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *sidecarSet) Clone() SidecarSet {
	if s == nil {
		return nil
	}
	genericSortFunc := func(toInsert, existing ezkube.ResourceId) bool {
		return s.sortFunc(toInsert.(client.Object), existing.(client.Object))
	}
	genericEqualityFunc := func(a, b ezkube.ResourceId) bool {
		return s.equalityFunc(a.(client.Object), b.(client.Object))
	}
	return &sidecarSet{
		set: sksets.NewResourceSet(
			genericSortFunc,
			genericEqualityFunc,
			s.Generic().Clone().List()...,
		),
	}
}

func (s *sidecarSet) GetSortFunc() func(toInsert, existing client.Object) bool {
	return s.sortFunc
}

func (s *sidecarSet) GetEqualityFunc() func(a, b client.Object) bool {
	return s.equalityFunc
}
