// Code generated by MockGen. DO NOT EDIT.
// Source: ./reconcilers.go

// Package mock_controller is a generated GoMock package.
package mock_controller

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	controller "github.com/solo-io/external-apis/pkg/api/istio/extensions.istio.io/v1alpha1/controller"
	reconcile "github.com/solo-io/skv2/pkg/reconcile"
	v1alpha1 "istio.io/client-go/pkg/apis/extensions/v1alpha1"
	predicate "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// MockWasmPluginReconciler is a mock of WasmPluginReconciler interface.
type MockWasmPluginReconciler struct {
	ctrl     *gomock.Controller
	recorder *MockWasmPluginReconcilerMockRecorder
}

// MockWasmPluginReconcilerMockRecorder is the mock recorder for MockWasmPluginReconciler.
type MockWasmPluginReconcilerMockRecorder struct {
	mock *MockWasmPluginReconciler
}

// NewMockWasmPluginReconciler creates a new mock instance.
func NewMockWasmPluginReconciler(ctrl *gomock.Controller) *MockWasmPluginReconciler {
	mock := &MockWasmPluginReconciler{ctrl: ctrl}
	mock.recorder = &MockWasmPluginReconcilerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWasmPluginReconciler) EXPECT() *MockWasmPluginReconcilerMockRecorder {
	return m.recorder
}

// ReconcileWasmPlugin mocks base method.
func (m *MockWasmPluginReconciler) ReconcileWasmPlugin(obj *v1alpha1.WasmPlugin) (reconcile.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReconcileWasmPlugin", obj)
	ret0, _ := ret[0].(reconcile.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReconcileWasmPlugin indicates an expected call of ReconcileWasmPlugin.
func (mr *MockWasmPluginReconcilerMockRecorder) ReconcileWasmPlugin(obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileWasmPlugin", reflect.TypeOf((*MockWasmPluginReconciler)(nil).ReconcileWasmPlugin), obj)
}

// MockWasmPluginDeletionReconciler is a mock of WasmPluginDeletionReconciler interface.
type MockWasmPluginDeletionReconciler struct {
	ctrl     *gomock.Controller
	recorder *MockWasmPluginDeletionReconcilerMockRecorder
}

// MockWasmPluginDeletionReconcilerMockRecorder is the mock recorder for MockWasmPluginDeletionReconciler.
type MockWasmPluginDeletionReconcilerMockRecorder struct {
	mock *MockWasmPluginDeletionReconciler
}

// NewMockWasmPluginDeletionReconciler creates a new mock instance.
func NewMockWasmPluginDeletionReconciler(ctrl *gomock.Controller) *MockWasmPluginDeletionReconciler {
	mock := &MockWasmPluginDeletionReconciler{ctrl: ctrl}
	mock.recorder = &MockWasmPluginDeletionReconcilerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWasmPluginDeletionReconciler) EXPECT() *MockWasmPluginDeletionReconcilerMockRecorder {
	return m.recorder
}

// ReconcileWasmPluginDeletion mocks base method.
func (m *MockWasmPluginDeletionReconciler) ReconcileWasmPluginDeletion(req reconcile.Request) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReconcileWasmPluginDeletion", req)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReconcileWasmPluginDeletion indicates an expected call of ReconcileWasmPluginDeletion.
func (mr *MockWasmPluginDeletionReconcilerMockRecorder) ReconcileWasmPluginDeletion(req interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileWasmPluginDeletion", reflect.TypeOf((*MockWasmPluginDeletionReconciler)(nil).ReconcileWasmPluginDeletion), req)
}

// MockWasmPluginFinalizer is a mock of WasmPluginFinalizer interface.
type MockWasmPluginFinalizer struct {
	ctrl     *gomock.Controller
	recorder *MockWasmPluginFinalizerMockRecorder
}

// MockWasmPluginFinalizerMockRecorder is the mock recorder for MockWasmPluginFinalizer.
type MockWasmPluginFinalizerMockRecorder struct {
	mock *MockWasmPluginFinalizer
}

// NewMockWasmPluginFinalizer creates a new mock instance.
func NewMockWasmPluginFinalizer(ctrl *gomock.Controller) *MockWasmPluginFinalizer {
	mock := &MockWasmPluginFinalizer{ctrl: ctrl}
	mock.recorder = &MockWasmPluginFinalizerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWasmPluginFinalizer) EXPECT() *MockWasmPluginFinalizerMockRecorder {
	return m.recorder
}

// FinalizeWasmPlugin mocks base method.
func (m *MockWasmPluginFinalizer) FinalizeWasmPlugin(obj *v1alpha1.WasmPlugin) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FinalizeWasmPlugin", obj)
	ret0, _ := ret[0].(error)
	return ret0
}

// FinalizeWasmPlugin indicates an expected call of FinalizeWasmPlugin.
func (mr *MockWasmPluginFinalizerMockRecorder) FinalizeWasmPlugin(obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FinalizeWasmPlugin", reflect.TypeOf((*MockWasmPluginFinalizer)(nil).FinalizeWasmPlugin), obj)
}

// ReconcileWasmPlugin mocks base method.
func (m *MockWasmPluginFinalizer) ReconcileWasmPlugin(obj *v1alpha1.WasmPlugin) (reconcile.Result, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReconcileWasmPlugin", obj)
	ret0, _ := ret[0].(reconcile.Result)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReconcileWasmPlugin indicates an expected call of ReconcileWasmPlugin.
func (mr *MockWasmPluginFinalizerMockRecorder) ReconcileWasmPlugin(obj interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReconcileWasmPlugin", reflect.TypeOf((*MockWasmPluginFinalizer)(nil).ReconcileWasmPlugin), obj)
}

// WasmPluginFinalizerName mocks base method.
func (m *MockWasmPluginFinalizer) WasmPluginFinalizerName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WasmPluginFinalizerName")
	ret0, _ := ret[0].(string)
	return ret0
}

// WasmPluginFinalizerName indicates an expected call of WasmPluginFinalizerName.
func (mr *MockWasmPluginFinalizerMockRecorder) WasmPluginFinalizerName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WasmPluginFinalizerName", reflect.TypeOf((*MockWasmPluginFinalizer)(nil).WasmPluginFinalizerName))
}

// MockWasmPluginReconcileLoop is a mock of WasmPluginReconcileLoop interface.
type MockWasmPluginReconcileLoop struct {
	ctrl     *gomock.Controller
	recorder *MockWasmPluginReconcileLoopMockRecorder
}

// MockWasmPluginReconcileLoopMockRecorder is the mock recorder for MockWasmPluginReconcileLoop.
type MockWasmPluginReconcileLoopMockRecorder struct {
	mock *MockWasmPluginReconcileLoop
}

// NewMockWasmPluginReconcileLoop creates a new mock instance.
func NewMockWasmPluginReconcileLoop(ctrl *gomock.Controller) *MockWasmPluginReconcileLoop {
	mock := &MockWasmPluginReconcileLoop{ctrl: ctrl}
	mock.recorder = &MockWasmPluginReconcileLoopMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWasmPluginReconcileLoop) EXPECT() *MockWasmPluginReconcileLoopMockRecorder {
	return m.recorder
}

// RunWasmPluginReconciler mocks base method.
func (m *MockWasmPluginReconcileLoop) RunWasmPluginReconciler(ctx context.Context, rec controller.WasmPluginReconciler, predicates ...predicate.Predicate) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, rec}
	for _, a := range predicates {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunWasmPluginReconciler", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// RunWasmPluginReconciler indicates an expected call of RunWasmPluginReconciler.
func (mr *MockWasmPluginReconcileLoopMockRecorder) RunWasmPluginReconciler(ctx, rec interface{}, predicates ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, rec}, predicates...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunWasmPluginReconciler", reflect.TypeOf((*MockWasmPluginReconcileLoop)(nil).RunWasmPluginReconciler), varargs...)
}
